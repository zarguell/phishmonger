---
phase: 08-deferred-v1-0-work
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/library.ts
  - src/hooks/useCustomTechniques.ts
  - src/data/techniques.json
autonomous: true

must_haves:
  truths:
    - "CustomTechnique type extends base Technique with custom metadata"
    - "useCustomTechniques hook manages custom technique CRUD operations"
    - "Custom techniques persist in LocalStorage separately from built-in techniques"
    - "getAllTechniques() merges built-in and custom techniques"
  artifacts:
    - path: "src/types/library.ts"
      provides: "Type definitions for custom technique library"
      exports: ["CustomTechnique", "TechniqueLibrary"]
      min_lines: 30
    - path: "src/hooks/useCustomTechniques.ts"
      provides: "Hook for managing custom techniques with LocalStorage persistence"
      exports: ["useCustomTechniques"]
      min_lines: 70
  key_links:
    - from: "src/hooks/useCustomTechniques.ts"
      to: "localStorage"
      via: "CUSTOM_TECHNIQUES_KEY constant"
      pattern: "localStorage.*custom.*technique"
    - from: "src/types/library.ts"
      to: "src/types/annotations.ts"
      via: "extends Technique interface"
      pattern: "extends.*Technique"
---

<objective>
Custom technique library data model and persistence.

Purpose: Users can define their own phishing techniques beyond the built-in MITRE ATT&CK catalog, enabling organization-specific techniques and training scenarios.
Output: Type definitions, custom technique hook, and LocalStorage persistence for user-defined techniques.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-deferred-v1-0-work/08-DEFERRED-V1-0-WORK-RESEARCH.md

# Only reference prior plan SUMMARYs if genuinely needed
@src/types/annotations.ts
@src/data/techniques.json
@src/utils/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create library type definitions</name>
  <files>src/types/library.ts</files>
  <action>
    Create src/types/library.ts with custom technique types:

    1. Import base Technique type from annotations.ts
    2. Define CustomTechnique interface extending Technique:
       - isCustom: true (discriminator field)
       - createdAt: string (ISO timestamp)
       - organization?: string (optional, for org-specific techniques)
    3. Define TechniqueLibrary interface:
       - custom: Record<string, CustomTechnique>
       - builtIns: Technique[] (reference to imported techniques.json)

    Use TypeScript type narrowing on isCustom for safe discriminated unions.

    Do NOT create separate "user technique" types - CustomTechnique should be a true extension of the base Technique type for maximum compatibility.
  </action>
  <verify>test -f src/types/library.ts && grep -q "CustomTechnique" src/types/library.ts && grep -q "extends Technique" src/types/library.ts</verify>
  <done>library.ts with CustomTechnique extending base Technique type</done>
</task>

<task type="auto">
  <name>Task 2: Create useCustomTechniques hook</name>
  <files>src/hooks/useCustomTechniques.ts</files>
  <action>
    Create src/hooks/useCustomTechniques.ts for custom technique management:

    State:
    - customTechniques: Record<string, CustomTechnique>

    CRUD operations:
    - addCustomTechnique(technique: Omit<CustomTechnique, 'id' | 'isCustom' | 'createdAt'>): string
      - Generates ID: CUSTOM-{timestamp}
      - Adds isCustom: true, createdAt: now
      - Returns generated ID
    - updateCustomTechnique(id: string, updates: Partial<CustomTechnique>): void
    - deleteCustomTechnique(id: string): void
    - getCustomTechnique(id: string): CustomTechnique | undefined

    Merge operation:
    - getAllTechniques(builtIns: Technique[]): Technique[]
      - Returns [...builtIns, ...customTechniques values]
      - Built-ins loaded from imported techniques.json

    Persistence:
    - CUSTOM_TECHNIQUES_KEY = 'phishmonger-custom-techniques'
    - Load from LocalStorage on mount
    - Save to LocalStorage on every change

    Reference RESEARCH.md lines 552-632 for exact implementation pattern.

    Do NOT validate against MITRE schema - custom techniques are user-defined and may not map to MITRE IDs.
  </action>
  <verify>test -f src/hooks/useCustomTechniques.ts && grep -q "useCustomTechniques" src/hooks/useCustomTechniques.ts && grep -q "CUSTOM_TECHNIQUES_KEY" src/hooks/useCustomTechniques.ts</verify>
  <done>useCustomTechniques hook with full CRUD, LocalStorage persistence, and merge operation</done>
</task>

<task type="auto">
  <name>Task 3: Verify techniques.json compatibility</name>
  <files>src/data/techniques.json</files>
  <action>
    Verify that src/data/techniques.json structure is compatible with CustomTechnique extension:

    1. Read existing techniques.json
    2. Confirm all required Technique fields are present: id, name, tactic, description, url
    3. If any techniques are missing fields, add placeholder values
    4. Ensure IDs are unique (no duplicates)

    This task ensures that getAllTechniques() can safely merge built-ins and custom techniques without type errors.

    If techniques.json is already valid (it should be from prior phases), this task is a no-op verification.
  </action>
  <verify>cat src/data/techniques.json | jq -e '.[] | select(.id == null or .name == null or .tactic == null or .description == null or .url == null)' && echo "Validation failed" || echo "All techniques valid"</verify>
  <done>techniques.json validated as compatible with CustomTechnique type extension</done>
</task>

</tasks>

<verification>
1. Custom technique can be added via hook
2. Custom technique persists to LocalStorage
3. Custom technique loads from LocalStorage on mount
4. getAllTechniques() merges built-ins and custom techniques
5. Custom technique has isCustom: true discriminator
6. Custom technique ID follows CUSTOM-{timestamp} pattern
</verification>

<success_criteria>
- Type-safe custom technique system extending base Technique
- LocalStorage persistence survives browser refresh
- Merge operation combines built-in and custom techniques
- CRUD operations work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-deferred-v1-0-work/08-05-SUMMARY.md`
</output>
