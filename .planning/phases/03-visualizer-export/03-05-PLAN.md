---
phase: 03-visualizer-export
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-04"]
files_modified: [src/components/export/ExportButton.tsx, src/utils/export.ts, src/App.tsx, src/index.css]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ExportButton triggers html2canvas to render slide as PNG"
    - "Exported image is 2x scale (3200px wide) for retina sharpness"
    - "Filename includes project title and timestamp"
    - "Exported PNG includes all highlights, arrows, badges, and cards"
  artifacts:
    - path: "src/components/export/ExportButton.tsx"
      provides: "Export button component with html2canvas integration"
    - path: "src/utils/export.ts"
      provides: "Export utility with filename generation"
      exports: ["exportSlideAsPNG"]
  key_links:
    - from: "ExportButton.tsx"
      to: "html2canvas"
      via: "import statement"
      pattern: "import.*html2canvas"
    - from: "ExportButton.tsx"
      to: "src/utils/export.ts"
      via: "import and function call"
      pattern: "exportSlideAsPNG"
    - from: "src/utils/export.ts"
      to: "SlideWrapper ref"
      via: "DOM element passed to html2canvas"
      pattern: "html2canvas.*element"
---

<objective>
Integrate html2canvas for high-resolution PNG export of annotated slides.

Purpose: Enable users to download the complete annotated email as a presentation-ready image with burned-in overlays.
Output: ExportButton component and export utility with html2canvas integration.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-visualizer-export/03-CONTEXT.md
@.planning/phases/03-visualizer-export/03-RESEARCH.md

@src/components/preview/SlideWrapper.tsx
@src/App.tsx

# html2canvas installed in Plan 01
@.planning/phases/03-visualizer-export/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create export utility with html2canvas wrapper</name>
  <files>src/utils/export.ts</files>
  <action>
    Create src/utils/export.ts:

    ```typescript
    import html2canvas from 'html2canvas'

    /**
     * Exports a DOM element as high-resolution PNG using html2canvas.
     * Per Phase 3 Research: scale: 2 for retina sharpness (3200px wide).
     *
     * @param element - The DOM element to capture (e.g., SlideWrapper)
     * @param filename - Base filename for the download (without extension)
     */
    export async function exportSlideAsPNG(
      element: HTMLElement,
      filename: string
    ): Promise<void> {
      try {
        const canvas = await html2canvas(element, {
          scale: 2,                    // 2x for retina sharpness (3200px wide)
          useCORS: true,              // Handle cross-origin images if present
          logging: false,             // Disable console spam
          backgroundColor: '#FFFFFF', // White background
        })

        // Convert canvas to PNG data URL
        const dataUrl = canvas.toDataURL('image/png')

        // Trigger download
        const link = document.createElement('a')
        link.download = `${filename}.png`
        link.href = dataUrl
        link.click()
      } catch (error) {
        console.error('Export failed:', error)
        throw new Error('Failed to export slide as PNG')
      }
    }

    /**
     * Generates filename with timestamp.
     * Format: phish-analysis-{title}-{timestamp}.png
     */
    export function generateExportFilename(projectTitle?: string): string {
      const sanitizedTitle = projectTitle
        ? projectTitle.toLowerCase().replace(/[^a-z0-9]+/g, '-')
        : 'untitled'
      const timestamp = new Date().toISOString().replace(/[:.]/g, '').slice(0, -5)
      return `phish-analysis-${sanitizedTitle}-${timestamp}`
    }
    ```

    Why scale: 2: Per Phase 3 Context, 2x scale renders at 3200px wide for retina sharpness. Ensures presentations look crisp on 4K projectors and when zoomed/cropped.

    Why useCORS: true: Per Phase 3 Research, handles any cross-origin images that might be present in the email content.

    Why logging: false: html2canvas is verbose by default. Disabling prevents console spam.

    Error handling: Catches html2canvas failures (e.g., unsupported CSS) and re-throws with user-friendly message. ExportButton will show toast notification.
  </action>
  <verify>test -f src/utils/export.ts && grep -q "html2canvas" src/utils/export.ts</verify>
  <done>Export utility created with html2canvas wrapper and filename generator</done>
</task>

<task type="auto">
  <name>Create ExportButton component</name>
  <files>src/components/export/ExportButton.tsx</files>
  <action>
    Create src/components/export/ExportButton.tsx:

    ```tsx
    import React, { useState } from 'react'
    import { exportSlideAsPNG, generateExportFilename } from '../../utils/export'

    interface ExportButtonProps {
      slideWrapperRef: React.RefObject<HTMLDivElement>
      projectTitle?: string
      disabled?: boolean
    }

    export function ExportButton({
      slideWrapperRef,
      projectTitle,
      disabled = false,
    }: ExportButtonProps) {
      const [isExporting, setIsExporting] = useState(false)
      const [error, setError] = useState<string | null>(null)

      const handleExport = async () => {
        if (!slideWrapperRef.current) {
          setError('Slide wrapper not found')
          return
        }

        setIsExporting(true)
        setError(null)

        try {
          const filename = generateExportFilename(projectTitle)
          await exportSlideAsPNG(slideWrapperRef.current, filename)
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Export failed')
          // TODO: Show toast notification (deferred to Phase 5)
          console.error('Export error:', err)
        } finally {
          setIsExporting(false)
        }
      }

      return (
        <div className="export-button-container">
          <button
            onClick={handleExport}
            disabled={disabled || isExporting}
            className="export-button"
            type="button"
          >
            {isExporting ? 'Exporting...' : 'Export PNG'}
          </button>
          {error && <div className="export-error">{error}</div>}
        </div>
      )
    }
    ```

    Why disabled state: Export takes 1-3 seconds with html2canvas. Button shows "Exporting..." state to prevent double-clicks and provide feedback.

    Why error handling: html2canvas can fail (e.g., tainted canvas from cross-origin images). Error message helps user understand what went wrong.

    TODO: Toast notification deferred to Phase 5 (Data & Persistence) when notification system is added.
  </action>
  <verify>test -f src/components/export/ExportButton.tsx && grep -q "ExportButton" src/components/export/ExportButton.tsx</verify>
  <done>ExportButton component created with loading and error states</done>
</task>

<task type="auto">
  <name>Add ExportButton to App.tsx with preview mode toggle</name>
  <files>src/App.tsx</files>
  <action>
    Update src/App.tsx to add preview mode and export button:

    ```tsx
    import { useState, useEffect, useRef } from 'react'
    import { HTMLInput } from './components/HTMLInput'
    import { Editor } from './components/Editor'
    import type { InputMode } from './components/ModeToggle'
    import { Preview } from './components/Preview'
    import { LureList } from './components/LureList'
    import { SlideWrapper } from './components/preview/SlideWrapper'
    import { EmailColumn } from './components/preview/EmailColumn'
    import { AnnotationColumn } from './components/preview/AnnotationColumn'
    import { ExportButton } from './components/export/ExportButton'
    import type { Annotation } from './types/annotations'
    import { loadAnnotations, saveAnnotations } from './utils/storage'
    import './index.css'

    const STORAGE_KEY = 'phishmonger-html-source'
    const MODE_KEY = 'phishmonger-input-mode'

    type ViewMode = 'edit' | 'preview'

    function App() {
      const [inputMode, setInputMode] = useState<InputMode>(() => {
        const savedMode = localStorage.getItem(MODE_KEY) as InputMode | null
        return savedMode || 'html'
      })
      const [htmlSource, setHtmlSource] = useState(() => {
        const saved = localStorage.getItem(STORAGE_KEY)
        return saved || '<p>Start typing your phishing email here...</p>'
      })
      const [annotations, setAnnotations] = useState<Record<string, Annotation>>(() => {
        return loadAnnotations()
      })
      const [viewMode, setViewMode] = useState<ViewMode>('edit')
      const slideWrapperRef = useRef<HTMLDivElement>(null)

      // Save to LocalStorage whenever htmlSource changes
      useEffect(() => {
        localStorage.setItem(STORAGE_KEY, htmlSource)
      }, [htmlSource])

      // Save input mode preference
      useEffect(() => {
        localStorage.setItem(MODE_KEY, inputMode)
      }, [inputMode])

      // Save annotations to LocalStorage
      useEffect(() => {
        saveAnnotations(annotations)
      }, [annotations])

      const updateAnnotation = (lureId: string, updates: Partial<Annotation>) => {
        setAnnotations(prev => ({
          ...prev,
          [lureId]: {
            ...prev[lureId],
            ...updates,
            lureId,
            updatedAt: new Date().toISOString()
          }
        }))
      }

      const handleMarkLure = (updatedHtml: string) => {
        setHtmlSource(updatedHtml)
      }

      const handleRemoveLure = (lureId: string) => {
        // Remove all spans with matching data-lure-id from HTML source
        const parser = new DOMParser()
        const doc = parser.parseFromString(htmlSource, 'text/html')
        const lureElements = doc.querySelectorAll(`[data-lure-id="${lureId}"]`)

        lureElements.forEach((el) => {
          const parent = el.parentNode
          if (parent) {
            while (el.firstChild) {
              parent.insertBefore(el.firstChild, el)
            }
            parent.removeChild(el)
          }
        })

        setHtmlSource(doc.body.innerHTML)

        // Remove annotation
        setAnnotations(prev => {
          const { [lureId]: removed, ...rest } = prev
          return rest
        })
      }

      if (viewMode === 'preview') {
        return (
          <div className="app app-preview-mode">
            <header className="app-header">
              <h1>Phish Monger - Preview Mode</h1>
              <div className="header-actions">
                <button
                  onClick={() => setViewMode('edit')}
                  className="back-to-edit-button"
                  type="button"
                >
                  Back to Edit
                </button>
                <ExportButton
                  slideWrapperRef={slideWrapperRef}
                  projectTitle="phish-analysis"
                />
              </div>
            </header>
            <main className="app-main app-main-preview">
              <SlideWrapper
                ref={slideWrapperRef}
                annotations={annotations}
              >
                <EmailColumn htmlSource={htmlSource} />
                <AnnotationColumn annotations={annotations} />
              </SlideWrapper>
            </main>
          </div>
        )
      }

      return (
        <div className="app">
          <header className="app-header">
            <h1>Phish Monger</h1>
            <p>Phishing Email Annotation Tool</p>
            <div className="header-actions">
              <button
                onClick={() => setViewMode('preview')}
                className="preview-mode-button"
                type="button"
                disabled={Object.keys(annotations).length === 0}
              >
                Preview Mode
              </button>
            </div>
          </header>
          <main className="app-main">
            <div className="input-column">
              <div className="mode-toggle">
                <label className="mode-toggle-label">
                  <input
                    type="radio"
                    name="inputMode"
                    value="html"
                    checked={inputMode === 'html'}
                    onChange={(e) => setInputMode(e.target.value as InputMode)}
                  />
                  <span>HTML Input</span>
                </label>
                <label className="mode-toggle-label">
                  <input
                    type="radio"
                    name="inputMode"
                    value="richtext"
                    checked={inputMode === 'richtext'}
                    onChange={(e) => setInputMode(e.target.value as InputMode)}
                  />
                  <span>Rich Text</span>
                </label>
              </div>
              {inputMode === 'html' ? (
                <HTMLInput
                  value={htmlSource}
                  onChange={setHtmlSource}
                />
              ) : (
                <Editor
                  content={htmlSource}
                  onUpdate={setHtmlSource}
                />
              )}
            </div>
            <div className="preview-column">
              <Preview
                htmlSource={htmlSource}
                onUpdate={handleMarkLure}
              />
            </div>
            <div className="lure-list-column">
              <LureList
                htmlSource={htmlSource}
                onRemoveLure={handleRemoveLure}
                annotations={annotations}
                onUpdateAnnotation={updateAnnotation}
              />
            </div>
          </main>
        </div>
      )
    }

    export default App
    ```

    Changes:
    - Add ViewMode type ('edit' | 'preview')
    - Add viewMode state and setViewMode function
    - Add slideWrapperRef for export
    - Import SlideWrapper, EmailColumn, AnnotationColumn, ExportButton
    - Add conditional rendering: if viewMode === 'preview', show slide layout
    - Add "Preview Mode" button in edit mode header
    - Add "Back to Edit" and "Export PNG" buttons in preview mode header
    - Disable Preview Mode button when no annotations exist

    Why conditional rendering: Per Phase 3 architecture, Preview Mode is a separate view showing the slide layout with annotations and arrows. Edit Mode shows the three-column editor workflow.

    Why disable preview when no annotations: Preview mode requires annotations to render cards and arrows. Empty state is handled in AnnotationColumn, but preventing accidental preview is better UX.

    Note: forwardRef pattern needed for SlideWrapper to accept ref from App.tsx. This is addressed in the verification step.
  </action>
  <verify>grep -q "ViewMode" src/App.tsx && grep -q "ExportButton" src/App.tsx && grep -q "SlideWrapper" src/App.tsx</verify>
  <done>App.tsx updated with preview mode toggle and export button</done>
</task>

<task type="auto">
  <name>Update SlideWrapper to accept forwarded ref</name>
  <files>src/components/preview/SlideWrapper.tsx</files>
  <action>
    Update src/components/preview/SlideWrapper.tsx to accept forwarded ref:

    ```tsx
    import React, { useRef, forwardRef } from 'react'
    import { useArrowCalculations } from '../../hooks/useArrowCalculations'
    import { useDebouncedResize } from '../../hooks/useDebouncedResize'
    import { ArrowOverlay } from './ArrowOverlay'

    interface SlideWrapperProps {
      children: React.ReactNode
      annotations: Record<string, import('../../types/annotations').Annotation>
    }

    export const SlideWrapper = forwardRef<HTMLDivElement, SlideWrapperProps>(
      ({ children, annotations }, ref) => {
        const internalRef = useRef<HTMLDivElement>(null)
        const containerRef = (ref as React.RefObject<HTMLDivElement>) || internalRef

        const { arrowPaths, recalculate } = useArrowCalculations({
          containerRef,
          annotations,
        })

        // Recalculate arrows on window resize (debounced 200ms)
        useDebouncedResize(recalculate, 200)

        return (
          <div ref={containerRef} className="slide-wrapper">
            {children}
            <ArrowOverlay paths={arrowPaths} />
          </div>
        )
      }
    )

    SlideWrapper.displayName = 'SlideWrapper'
    ```

    Changes:
    - Wrap component in forwardRef
    - Accept ref as second parameter
    - Use internalRef if no ref passed
    - Add displayName for React DevTools

    Why forwardRef: App.tsx needs to pass a ref to SlideWrapper for html2canvas export. React requires forwardRef pattern for components to expose their internal DOM refs to parents.
  </action>
  <verify>grep -q "forwardRef" src/components/preview/SlideWrapper.tsx && grep -q "displayName" src/components/preview/SlideWrapper.tsx</verify>
  <done>SlideWrapper accepts forwarded ref for export</done>
</task>

<task type="auto">
  <name>Add CSS for preview mode and export button</name>
  <files>src/index.css</files>
  <action>
    Add CSS to src/index.css for preview mode and export button:

    ```css
    /* Preview Mode Layout */
    .app-preview-mode {
      width: 100%;
      min-height: 100vh;
      background: #f8f9fa;
    }

    .app-main-preview {
      display: flex;
      justify-content: center;
      padding: 40px;
      overflow: auto;
    }

    /* Header Actions */
    .header-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    /* Preview Mode Button */
    .preview-mode-button {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .preview-mode-button:hover:not(:disabled) {
      background: #0056b3;
    }

    .preview-mode-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Back to Edit Button */
    .back-to-edit-button {
      padding: 8px 16px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .back-to-edit-button:hover {
      background: #545b62;
    }

    /* Export Button */
    .export-button {
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .export-button:hover:not(:disabled) {
      background: #218838;
    }

    .export-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Export Error */
    .export-error {
      margin-top: 8px;
      padding: 8px 12px;
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      border-radius: 4px;
      font-size: 12px;
    }

    .export-button-container {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    ```

    Why button colors: Green (#28a745) for export (success action), Blue (#007bff) for preview mode (primary action), Gray (#6c757d) for back button (secondary action).

    Why overflow: auto on .app-main-preview: The slide wrapper is 1600px wide, which may exceed viewport width on smaller screens. overflow: auto enables horizontal scrolling to view the full slide.

    Note: box-shadow and filter properties are NOT used in export-related CSS since html2canvas has limited support (per Phase 3 Research Pitfall 3).
  </action>
  <verify>grep -q "\.export-button" src/index.css && grep -q "\.preview-mode-button" src/index.css</verify>
  <done>CSS for preview mode and export button added</done>
</task>

</tasks>

<verification>
- ExportButton renders in preview mode header
- Clicking export generates PNG file with correct filename format
- Exported PNG is 3200px wide (2x scale of 1600px)
- Exported image includes all highlights, cards, arrows, and badges
- Preview mode toggle switches between edit and preview views
- Preview mode is disabled when no annotations exist
- Back to Edit button returns to editor view
- SlideWrapper accepts forwarded ref from App.tsx
- Export shows "Exporting..." state during html2canvas rendering
- Export errors display to user (console + inline message)
</verification>

<success_criteria>
- User can toggle to Preview Mode showing slide with annotations and arrows
- Export button downloads high-resolution PNG (2x scale)
- Exported filename format: phish-analysis-{title}-{timestamp}.png
- Exported PNG includes all visual elements burned in
- All 6 VIS requirements satisfied (VIS-01 through VIS-06)
- Phase 3 complete and ready for Phase 4 (NIST Phish Scale Scoring)
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualizer-export/03-05-SUMMARY.md`
</output>
