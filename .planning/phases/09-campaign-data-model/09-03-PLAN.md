---
phase: 09-campaign-data-model
plan: 03
type: execute
wave: 2
depends_on:
  - 09-01
files_modified:
  - src/hooks/useCampaigns.ts
  - src/utils/campaignCopy.ts
autonomous: true

must_haves:
  truths:
    - "useCampaigns hook provides campaigns state and isLoaded flag"
    - "addCampaign creates new campaign with crypto.randomUUID() and ISO timestamp"
    - "updateCampaign modifies existing campaign by id"
    - "deleteCampaign removes campaign from state and LocalStorage"
    - "addPhishToCampaign copies phish into campaign.campaignPhishes array"
    - "removePhishFromCampaign removes phish from campaign.campaignPhishes array"
    - "updatePhishInCampaign modifies specific phish within campaign"
    - "All CRUD operations persist to LocalStorage via saveCampaigns"
    - "QuotaExceededError sets storageError state for inline display"
    - "copyPhishForCampaign utility creates independent phish copy"
  artifacts:
    - path: "src/hooks/useCampaigns.ts"
      provides: "Campaign CRUD hook following useCustomTechniques pattern"
      exports: ["useCampaigns", "CAMPAIGNS_KEY"]
      min_lines: 100
    - path: "src/utils/campaignCopy.ts"
      provides: "Phish copying utilities for campaign workflow"
      exports: ["copyPhishForCampaign"]
      min_lines: 30
  key_links:
    - from: "src/hooks/useCampaigns.ts"
      to: "src/utils/storage.ts"
      via: "import loadCampaigns, saveCampaigns"
      pattern: "import.*loadCampaigns.*saveCampaigns"
    - from: "src/hooks/useCampaigns.ts"
      to: "src/types/campaign.ts"
      via: "import Campaign, CampaignInput"
      pattern: "import.*Campaign.*from.*types"
    - from: "src/utils/campaignCopy.ts"
      to: "src/types/phish.ts"
      via: "import Phish, PhishInput"
      pattern: "import.*Phish.*from.*types"
---

<objective>
useCampaigns hook with CRUD operations and phish copying utilities.

Purpose: Provide React hook for campaign management following the established useCustomTechniques pattern. Campaigns contain copied phish data (not references) for portability, with utilities for deep-copying phishes when adding to campaigns. All operations persist to LocalStorage with quota error handling.
Output: Working useCampaigns hook with full CRUD API, copyPhishForCampaign utility, and storage error state management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/09-campaign-data-model/09-CONTEXT.md
@.planning/phases/09-campaign-data-model/09-RESEARCH.md
@.planning/phases/09-campaign-data-model/09-01-SUMMARY.md

@src/hooks/useCustomTechniques.ts
@src/utils/storage.ts
@src/types/campaign.ts
@src/types/phish.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create phish copying utility for campaigns</name>
  <files>src/utils/campaignCopy.ts</files>
  <action>
    Create src/utils/campaignCopy.ts with phish copying utilities:

    ```typescript
    /**
     * Phish copying utilities for campaign management
     *
     * When adding a phish to a campaign, we create an independent copy
     * so that edits within the campaign don't affect the source library
     * project. This enables campaigns to be fully self-contained and
     * portable.
     */

    import type { Phish, PhishInput } from '../types/phish';
    import type { Annotation } from '../types/annotations';
    import type { ScoringData } from '../types/scoring';
    import type { ProjectMetadata } from '../types/project';
    import type { InputMode } from '../components/ModeToggle';

    /**
     * Create a deep copy of a phish for campaign use
     *
     * Per CONTEXT.md:
     * - Keep original UUIDs from library project (no new IDs generated)
     * - No back-reference to origin project (copies are truly independent)
     * - Deep copy annotations, scoring, and metadata
     *
     * @param phish - Source phish to copy
     * @returns Independent phish copy for campaign use
     */
    export function copyPhishForCampaign(phish: Phish): Phish {
      // Deep copy annotations to prevent shared reference
      const copiedAnnotations: Record<string, Annotation> = {};
      for (const [lureId, annotation] of Object.entries(phish.annotations)) {
        copiedAnnotations[lureId] = { ...annotation };
      }

      // Deep copy scoring data
      const copiedScoring: ScoringData = { ...phish.scoring };

      // Deep copy metadata
      const copiedMetadata: ProjectMetadata = {
        title: phish.metadata.title,
        author: phish.metadata.author,
        createdAt: phish.metadata.createdAt,
        updatedAt: phish.metadata.updatedAt,
      };

      // Create new phish with original UUID, copied data
      return {
        id: phish.id, // Keep original UUID
        metadata: copiedMetadata,
        htmlSource: phish.htmlSource, // Strings are immutable in JS
        annotations: copiedAnnotations,
        scoring: copiedScoring,
        inputMode: phish.inputMode,
        scheduledDate: phish.scheduledDate,
      };
    }

    /**
     * Create a new phish from input data
     *
     * Generates new UUID using crypto.randomUUID()
     *
     * @param input - Phish data without id
     * @returns New phish with generated id
     */
    export function createPhish(input: PhishInput): Phish {
      return {
        ...input,
        id: crypto.randomUUID(),
      };
    }
    ```

    Key decisions from CONTEXT.md:
    - Keep original UUIDs when copying (no new IDs generated)
    - No back-reference to origin project
    - Deep copy nested objects (annotations, scoring, metadata)
    - Use crypto.randomUUID() for new phish creation

    DO NOT add originProjectId or any back-reference - copies are independent.
  </action>
  <verify>test -f src/utils/campaignCopy.ts && grep -q "copyPhishForCampaign" src/utils/campaignCopy.ts && grep -q "crypto.randomUUID()" src/utils/campaignCopy.ts</verify>
  <done>copyPhishForCampaign and createPhish utilities created with proper deep copying</done>
</task>

<task type="auto">
  <name>Task 2: Create useCampaigns hook following useCustomTechniques pattern</name>
  <files>src/hooks/useCampaigns.ts</files>
  <action>
    Create src/hooks/useCampaigns.ts following the useCustomTechniques pattern:

    ```typescript
    /**
     * Campaign management hook
     *
     * Provides CRUD operations for campaign management with LocalStorage
     * persistence. Follows the same pattern as useCustomTechniques for
     * consistency across the codebase.
     *
     * Campaigns contain copied phish data (not references) for portability.
     * Use copyPhishForCampaign() to add phishes to campaigns.
     */

    import { useState, useEffect, useCallback } from 'react';
    import type { Campaign, CampaignInput, CampaignPhish } from '../types/campaign';
    import type { Phish } from '../types/phish';
    import { loadCampaigns, saveCampaigns } from '../utils/storage';

    /**
     * LocalStorage key for campaigns persistence
     */
    export const CAMPAIGNS_KEY = 'phishmonger-campaigns';

    /**
     * Hook for managing campaigns
     *
     * Provides:
     * - Campaign CRUD operations (add, update, delete)
     * - Phish management within campaigns (add, remove, update)
     * - Automatic LocalStorage persistence
     * - Storage error state for quota handling
     * - Load on mount from LocalStorage
     *
     * @returns Object containing campaigns state and operations
     */
    export function useCampaigns() {
      const [campaigns, setCampaigns] = useState<Campaign[]>([]);
      const [isLoaded, setIsLoaded] = useState(false);
      const [storageError, setStorageError] = useState<string | null>(null);

      /**
       * Load campaigns from LocalStorage on mount
       */
      useEffect(() => {
        const loaded = loadCampaigns();
        setCampaigns(loaded);
        setIsLoaded(true);
      }, []);

      /**
       * Save campaigns to LocalStorage with quota error handling
       */
      const saveToStorage = useCallback((campaignsToSave: Campaign[]) => {
        try {
          setStorageError(null);
          saveCampaigns(campaignsToSave);
        } catch (error) {
          if (error instanceof Error && error.name === 'QuotaExceededError') {
            setStorageError('Storage nearly full. Delete old campaigns or export data.');
          } else {
            console.error('Failed to save campaigns:', error);
            setStorageError('Failed to save campaigns.');
          }
        }
      }, []);

      /**
       * Add a new campaign
       *
       * @param input - Campaign data without id and createdAt
       * @returns Created campaign with generated id
       */
      const addCampaign = useCallback((input: CampaignInput): Campaign => {
        const newCampaign: Campaign = {
          ...input,
          id: crypto.randomUUID(),
          createdAt: new Date().toISOString(),
        };

        const updated = [...campaigns, newCampaign];
        setCampaigns(updated);
        saveToStorage(updated);

        return newCampaign;
      }, [campaigns, saveToStorage]);

      /**
       * Update an existing campaign
       *
       * @param id - Campaign ID to update
       * @param updates - Partial campaign data to merge
       */
      const updateCampaign = useCallback((id: string, updates: Partial<Omit<Campaign, 'id' | 'createdAt'>>): void => {
        const existing = campaigns.find(c => c.id === id);
        if (!existing) {
          console.warn(`Cannot update non-existent campaign: ${id}`);
          return;
        }

        const updated = campaigns.map(c =>
          c.id === id
            ? { ...c, ...updates }
            : c
        );

        setCampaigns(updated);
        saveToStorage(updated);
      }, [campaigns, saveToStorage]);

      /**
       * Delete a campaign
       *
       * @param id - Campaign ID to delete
       */
      const deleteCampaign = useCallback((id: string): void => {
        const existing = campaigns.find(c => c.id === id);
        if (!existing) {
          console.warn(`Cannot delete non-existent campaign: ${id}`);
          return;
        }

        const updated = campaigns.filter(c => c.id !== id);
        setCampaigns(updated);
        saveToStorage(updated);
      }, [campaigns, saveToStorage]);

      /**
       * Add a phish to a campaign
       *
       * Copies the phish into the campaign's phish array.
       * Use copyPhishForCampaign() to create an independent copy.
       *
       * @param campaignId - Campaign ID to add phish to
       * @param phish - Phish to add (should be a copy from copyPhishForCampaign)
       */
      const addPhishToCampaign = useCallback((campaignId: string, phish: CampaignPhish): void => {
        const campaign = campaigns.find(c => c.id === campaignId);
        if (!campaign) {
          console.warn(`Cannot add phish to non-existent campaign: ${campaignId}`);
          return;
        }

        const updated = campaigns.map(c =>
          c.id === campaignId
            ? { ...c, campaignPhishes: [...c.campaignPhishes, phish] }
            : c
        );

        setCampaigns(updated);
        saveToStorage(updated);
      }, [campaigns, saveToStorage]);

      /**
       * Remove a phish from a campaign
       *
       * @param campaignId - Campaign ID to remove phish from
       * @param phishId - Phish ID to remove
       */
      const removePhishFromCampaign = useCallback((campaignId: string, phishId: string): void => {
        const campaign = campaigns.find(c => c.id === campaignId);
        if (!campaign) {
          console.warn(`Cannot remove phish from non-existent campaign: ${campaignId}`);
          return;
        }

        const updated = campaigns.map(c =>
          c.id === campaignId
            ? { ...c, campaignPhishes: c.campaignPhishes.filter(p => p.id !== phishId) }
            : c
        );

        setCampaigns(updated);
        saveToStorage(updated);
      }, [campaigns, saveToStorage]);

      /**
       * Update a phish within a campaign
       *
       * @param campaignId - Campaign ID containing the phish
       * @param phishId - Phish ID to update
       * @param updates - Partial phish data to merge
       */
      const updatePhishInCampaign = useCallback((campaignId: string, phishId: string, updates: Partial<Omit<CampaignPhish, 'id'>>): void => {
        const campaign = campaigns.find(c => c.id === campaignId);
        if (!campaign) {
          console.warn(`Cannot update phish in non-existent campaign: ${campaignId}`);
          return;
        }

        const updated = campaigns.map(c => {
          if (c.id === campaignId) {
            const updatedPhishes = c.campaignPhishes.map(p =>
              p.id === phishId ? { ...p, ...updates } : p
            );
            return { ...c, campaignPhishes: updatedPhishes };
          }
          return c;
        });

        setCampaigns(updated);
        saveToStorage(updated);
      }, [campaigns, saveToStorage]);

      /**
       * Get a single campaign by ID
       *
       * @param id - Campaign ID to retrieve
       * @returns Campaign if found, undefined otherwise
       */
      const getCampaign = useCallback((id: string): Campaign | undefined => {
        return campaigns.find(c => c.id === id);
      }, [campaigns]);

      return {
        campaigns,
        isLoaded,
        storageError,
        addCampaign,
        updateCampaign,
        deleteCampaign,
        addPhishToCampaign,
        removePhishFromCampaign,
        updatePhishInCampaign,
        getCampaign,
      };
    }
    ```

    Follow useCustomTechniques pattern:
    - useState for campaigns, isLoaded
    - useEffect to load from LocalStorage on mount
    - useCallback for all operations with proper dependencies
    - Functional updates not needed (no derived state complexity)
    - Console warnings for invalid operations (non-existent IDs)
    - storageError state for QuotaExceededError display

    DO NOT add relationship validation - campaigns don't reference library projects per CONTEXT.md.
  </action>
  <verify>test -f src/hooks/useCampaigns.ts && grep -q "export function useCampaigns" src/hooks/useCampaigns.ts && grep -q "CAMPAIGNS_KEY" src/hooks/useCampaigns.ts</verify>
  <done>useCampaigns hook created with full CRUD API following useCustomTechniques pattern</done>
</task>

</tasks>

<verification>
1. Check that useCampaigns loads from LocalStorage on mount
2. Check that addCampaign generates unique IDs with crypto.randomUUID()
3. Check that updateCampaign modifies only the target campaign
4. Check that deleteCampaign removes campaign from state
5. Check that addPhishToCampaign adds phish to campaign.campaignPhishes
6. Check that removePhishFromCampaign removes phish from campaign.campaignPhishes
7. Check that QuotaExceededError sets storageError state
</verification>

<success_criteria>
- useCampaigns hook provides complete CRUD operations for campaigns
- Phishes can be added/removed/updated within campaigns
- Storage quota errors set storageError for inline display
- Hook follows useCustomTechniques pattern for consistency
- All operations persist to LocalStorage
</success_criteria>

<output>
After completion, create `.planning/phases/09-campaign-data-model/09-03-SUMMARY.md`
</output>
