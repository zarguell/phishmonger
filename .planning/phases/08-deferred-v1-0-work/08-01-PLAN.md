---
phase: 08-deferred-v1-0-work
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/hooks/useUndoRedo.ts
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can undo last action via Ctrl+Z / Cmd+Z"
    - "User can redo via Ctrl+Shift+Z / Ctrl+Y"
    - "Undo/redo buttons disabled when no history available"
    - "History limited to 50 steps to prevent memory issues"
    - "Keyboard shortcuts respect form input context (don't fire when typing in text fields)"
  artifacts:
    - path: "src/hooks/useUndoRedo.ts"
      provides: "Undo/redo history management hook"
      exports: ["useUndoRedo"]
      min_lines: 50
    - path: "package.json"
      provides: "react-hotkeys-hook dependency"
      contains: "react-hotkeys-hook"
  key_links:
    - from: "src/App.tsx"
      to: "src/hooks/useUndoRedo.ts"
      via: "import useUndoRedo"
      pattern: "import.*useUndoRedo"
    - from: "src/App.tsx"
      to: "global keyboard event"
      via: "useHotkeys from react-hotkeys-hook"
      pattern: "useHotkeys.*ctrl\\+z"
---

<objective>
Undo/redo functionality with keyboard shortcuts for state management.

Purpose: Users can safely explore edits without fear of losing work - a critical UX feature for any content creation tool.
Output: Working undo/redo system with 50-step history limit, keyboard shortcuts (Ctrl+Z/Cmd+Z for undo, Ctrl+Shift+Z/Ctrl+Y for redo), and visual undo/redo buttons.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-deferred-v1-0-work/08-DEFERRED-V1-0-WORK-RESEARCH.md

# Only reference prior plan SUMMARYs if genuinely needed
@src/App.tsx
@src/types/annotations.ts
@src/utils/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-hotkeys-hook dependency</name>
  <files>package.json, package-lock.json</files>
  <action>
    Install react-hotkeys-hook for global keyboard shortcut management:
    ```bash
    npm install react-hotkeys-hook
    ```

    This library provides declarative keyboard shortcut handling with proper form tag scoping.
    Do NOT use alternatives like react-keybinds or manual event listeners (research validated).
  </action>
  <verify>grep -q '"react-hotkeys-hook"' package.json && npm list react-hotkeys-hook</verify>
  <done>react-hotkeys-hook installed and available in package.json</done>
</task>

<task type="auto">
  <name>Task 2: Create useUndoRedo hook</name>
  <files>src/hooks/useUndoRedo.ts</files>
  <action>
    Create src/hooks/useUndoRedo.ts implementing the undo/redo history pattern from RESEARCH.md:

    - Use useReducer with HistoryState<T> pattern (past/present/future arrays)
    - Implement MAX_HISTORY = 50 to prevent memory leaks (pitfall #1 from research)
    - Export: state, setState, undo, redo, canUndo, canRedo, clear
    - Use shallow copying for immutable state updates
    - Use useCallback for stable function references

    Reference the useReducer pattern from RESEARCH.md lines 75-153.

    Do NOT use external libraries like useUndoable or reddojs - the custom hook is simpler and type-safe.
  </action>
  <verify>test -f src/hooks/useUndoRedo.ts && grep -q "useReducer" src/hooks/useUndoRedo.ts && grep -q "MAX_HISTORY" src/hooks/useUndoRedo.ts</verify>
  <done>useUndoRedo hook created with useReducer pattern, 50-step history limit, full undo/redo API</done>
</task>

<task type="auto">
  <name>Task 3: Wire undo/redo into App.tsx</name>
  <files>src/App.tsx</files>
  <action>
    Integrate undo/redo into the application state:

    1. Import useUndoRedo and useHotkeys from react-hotkeys-hook
    2. Wrap annotations state with useUndoRedo (this is the primary state users want to undo)
    3. Add undo/redo buttons to app header in edit mode:
       - Position in header-actions div, before "Preview Mode" button
       - Disable buttons when canUndo/canRedo are false
       - Show keyboard shortcuts in title attributes
    4. Wire global keyboard shortcuts:
       - Ctrl+Z / Cmd+Z for undo
       - Ctrl+Shift+Z / Ctrl+Y / Cmd+Shift+Z for redo
       - Use enableOnFormTags: false to avoid conflicts with text input undo (pitfall #2 from research)

    CRITICAL: Only wrap annotations state with undo/redo. Do NOT wrap htmlSource (users expect separate undo history for text editors).

    The undo/redo should work for annotation changes: adding annotations, updating explanations, changing technique tags.
  </action>
  <verify>grep -q "useUndoRedo" src/App.tsx && grep -q "useHotkeys" src/App.tsx && grep -q "enableOnFormTags.*false" src/App.tsx</verify>
  <done>Annotations state wrapped with undo/redo; keyboard shortcuts work; undo/redo buttons visible in header</done>
</task>

</tasks>

<verification>
1. Type some text in HTML input, create an annotation, press Ctrl+Z - annotation should be removed
2. Press Ctrl+Shift+Z - annotation should be restored
3. Type in HTML input field - Ctrl+Z should undo TEXT within the field, not trigger global undo
4. Undo button should be disabled when no history available
5. After 50+ state changes, oldest history should be dropped (memory limit enforced)
</verification>

<success_criteria>
- Undo/redo works for all annotation mutations (add, update, delete)
- Keyboard shortcuts don't interfere with form input undo
- History limit of 50 steps prevents memory issues
- Visual buttons clearly indicate availability (disabled when no undo/redo possible)
</success_criteria>

<output>
After completion, create `.planning/phases/08-deferred-v1-0-work/08-01-SUMMARY.md`
</output>
