---
phase: 01-editor-foundation
plan: 05
type: execute
wave: 5
depends_on: ["01-04"]
files_modified: [src/components/ModeToggle.tsx, src/components/HTMLInput.tsx, src/components/Editor.tsx, src/App.tsx]
autonomous: true
gap_closure: true
user_setup: []

must_haves:
  truths:
    - "Mode toggle switches between HTML textarea and Rich Text editor"
    - "HTML mode accepts raw HTML paste"
    - "Rich Text mode uses Tiptap editor"
    - "Content is preserved when switching modes (HTML ↔ Tiptap)"
    - "Mode preference is saved to LocalStorage"
  artifacts:
    - path: "src/components/ModeToggle.tsx"
      provides: "Toggle switch component for HTML/Rich Text modes"
      exports: ["ModeToggle"]
      contains: "inputMode", "setInputMode"
      min_lines: 20
    - path: "src/components/HTMLInput.tsx"
      provides: "Textarea component for raw HTML input"
      exports: ["HTMLInput"]
      contains: "textarea", "value", "onChange"
      min_lines: 15
    - path: "src/App.tsx"
      provides: "Main app with mode toggle and conditional rendering"
      contains: "ModeToggle", "HTMLInput", "Editor", "inputMode"
    - path: "src/components/Editor.tsx"
      provides: "Simplified Tiptap editor without LureMark extension"
      contains: "useEditor", "EditorContent"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/ModeToggle.tsx"
      via: "ModeToggle component import"
      pattern: "import.*ModeToggle.*from.*components/ModeToggle"
    - from: "src/App.tsx"
      to: "src/components/HTMLInput.tsx"
      via: "HTMLInput component import"
      pattern: "import.*HTMLInput.*from.*components/HTMLInput"
    - from: "src/App.tsx"
      to: "src/components/Editor.tsx"
      via: "Editor component import"
      pattern: "import.*Editor.*from.*components/Editor"
    - from: "src/App.tsx"
      to: "localStorage"
      via: "useEffect for mode preference persistence"
      pattern: "localStorage\\.setItem.*mode|localStorage\\.getItem.*mode"
---

<objective>
Build a mode toggle that allows users to switch between HTML input mode (for pasting phishing emails) and Rich Text mode (for composing formatted content). The HTML input mode provides a textarea for raw HTML, while Rich Text mode uses the existing Tiptap editor (simplified, without LureMark extension).

Purpose: This implements the new split Editor/Viewer architecture from 01-04. Users can paste raw phishing email HTML directly (HTML mode) or compose formatted content (Rich Text mode). Mode preference and content are preserved across switches.

Output:
- ModeToggle.tsx: Radio button toggle switch for HTML/Rich Text modes
- HTMLInput.tsx: Textarea component for raw HTML input
- Editor.tsx: Simplified Tiptap editor (LureMark button removed)
- App.tsx: Integrated mode toggle with conditional rendering and content conversion
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/01-editor-foundation/01-04-ARCHITECTURAL-DECISION.md
@.planning/phases/01-editor-foundation/01-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Create ModeToggle component with switch UI</name>
  <files>src/components/ModeToggle.tsx</files>
  <action>
    Create src/components/ModeToggle.tsx:

    ```typescript
    import { useState } from 'react'

    export type InputMode = 'html' | 'richtext'

    interface ModeToggleProps {
      currentMode: InputMode
      onModeChange: (mode: InputMode) => void
    }

    export function ModeToggle({ currentMode, onModeChange }: ModeToggleProps) {
      return (
        <div className="mode-toggle">
          <label className="mode-toggle-label">
            <input
              type="radio"
              name="inputMode"
              value="html"
              checked={currentMode === 'html'}
              onChange={(e) => onModeChange(e.target.value as InputMode)}
            />
            <span>HTML Input</span>
          </label>
          <label className="mode-toggle-label">
            <input
              type="radio"
              name="inputMode"
              value="richtext"
              checked={currentMode === 'richtext'}
              onChange={(e) => onModeChange(e.target.value as InputMode)}
            />
            <span>Rich Text</span>
          </label>
        </div>
      )
    }
    ```

    Style as segmented control or tab-style toggle with active states.
  </action>
  <verify>
    Check that src/components/ModeToggle.tsx exists and exports ModeToggle component.
    Verify InputMode type is exported.
    Confirm radio button inputs for 'html' and 'richtext' modes.
  </verify>
  <done>
    ModeToggle component with radio button switch is created.
  </done>
</task>

<task type="auto">
  <name>Create HTMLInput component</name>
  <files>src/components/HTMLInput.tsx</files>
  <action>
    Create src/components/HTMLInput.tsx:

    ```typescript
    interface HTMLInputProps {
      value: string
      onChange: (html: string) => void
      placeholder?: string
    }

    export function HTMLInput({ value, onChange, placeholder }: HTMLInputProps) {
      return (
        <div className="html-input-container">
          <textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder || 'Paste phishing email HTML here...'}
            className="html-input-textarea"
            spellCheck={false}
          />
        </div>
      )
    }
    ```

    Features:
    - Controlled textarea component
    - Monospace font for HTML editing
    - Auto-resize or fixed height with scroll
    - Placeholder text for user guidance
  </action>
  <verify>
    Check that src/components/HTMLInput.tsx exists and exports HTMLInput component.
    Verify textarea is controlled (value, onChange props).
    Confirm placeholder text is present.
  </verify>
  <done>
    HTMLInput component for raw HTML input is created.
  </done>
</task>

<task type="auto">
  <name>Simplify Editor component (remove LureMark button)</name>
  <files>src/components/Editor.tsx</files>
  <action>
    Modify src/components/Editor.tsx:

    1. Remove LureMark extension import
    2. Remove LureMark from extensions array
    3. Remove "Mark Lure" button from toolbar
    4. Remove toolbar-divider (optional, or keep if other buttons follow)

    The simplified editor should have:
    - StarterKit extension
    - Link extension
    - Bold, Italic, Link toolbar buttons only
    - Paste sanitization (keep existing handlePaste)
    - onUpdate callback for content changes

    Reference: Existing Editor.tsx has LureMark button on lines 77-90. Remove this button.
  </action>
  <verify>
    Check that src/components/Editor.tsx no longer imports LureMark.
    Verify LureMark is not in extensions array.
    Confirm "Mark Lure" button is removed from toolbar.
    Ensure Bold, Italic, Link buttons still work.
  </verify>
  <done>
    Editor component is simplified without LureMark extension.
  </done>
</task>

<task type="auto">
  <name>Integrate mode toggle in App.tsx with content conversion</name>
  <files>src/App.tsx</files>
  <action>
    Modify src/App.tsx:

    1. Add inputMode state ('html' | 'richtext') initialized from localStorage
    2. Import ModeToggle, HTMLInput, and Editor components
    3. Add mode change handler that:
       - Saves mode preference to localStorage
       - Converts content when switching modes:
         - HTML → Rich Text: Load HTML into Tiptap editor
         - Rich Text → HTML: Get HTML from Tiptap editor
    4. Conditionally render HTMLInput OR Editor based on inputMode
    5. Update localStorage to store both HTML content and current mode

    Storage format:
    ```typescript
    interface StoredData {
      htmlContent: string
      mode: 'html' | 'richtext'
    }
    ```

    Example implementation:
    ```typescript
    const [inputMode, setInputMode] = useState<InputMode>(() => {
      const saved = localStorage.getItem('phishmonger-mode')
      return (saved as InputMode) || 'richtext'
    })

    const handleModeChange = (newMode: InputMode) => {
      if (newMode === inputMode) return

      if (inputMode === 'richtext' && newMode === 'html') {
        // Get HTML from Tiptap and switch to textarea
        // (handled by Editor.onUpdate keeping content in sync)
      }
      // html → richtext: Editor loads HTML content automatically

      setInputMode(newMode)
      localStorage.setItem('phishmonger-mode', newMode)
    }

    return (
      <div className="app">
        <header>...</header>
        <ModeToggle currentMode={inputMode} onModeChange={handleModeChange} />
        <main>
          {inputMode === 'html' ? (
            <HTMLInput value={content} onChange={setContent} />
          ) : (
            <Editor content={content} onUpdate={setContent} />
          )}
        </main>
      </div>
    )
    ```

    Position ModeToggle above the input area in the layout.
  </action>
  <verify>
    Check that src/App.tsx imports ModeToggle, HTMLInput, Editor.
    Verify inputMode state is initialized from localStorage.
    Confirm handleModeChange saves mode to localStorage.
    Check conditional rendering: HTMLInput for 'html' mode, Editor for 'richtext' mode.
    Verify content is preserved when switching modes (no data loss).
  </verify>
  <done>
    App.tsx integrates mode toggle with conditional rendering and content conversion.
  </done>
</task>

</tasks>

<verification>
1. Check src/components/ModeToggle.tsx - Exports ModeToggle component with InputMode type
2. Check src/components/HTMLInput.tsx - Exports controlled textarea component
3. Check src/components/Editor.tsx - LureMark extension and button removed
4. Check src/App.tsx - Imports ModeToggle, HTMLInput, Editor
5. Check src/App.tsx - Has inputMode state initialized from localStorage
6. Check src/App.tsx - Conditionally renders HTMLInput or Editor based on inputMode
7. Check src/App.tsx - Content is preserved when switching modes
8. Check src/App.tsx - Mode preference is saved to localStorage
</verification>

<success_criteria>
- User can click toggle to switch between HTML Input and Rich Text modes
- HTML Input mode shows textarea for raw HTML
- Rich Text mode shows simplified Tiptap editor (no LureMark button)
- Content is preserved when switching modes (HTML ↔ Tiptap)
- Mode preference is saved to LocalStorage
- HTML Input textarea has monospace font and placeholder text
- Mode toggle displays as radio buttons or segmented control
</success_criteria>

<output>
After completion, create `.planning/phases/01-editor-foundation/01-05-SUMMARY.md`
</output>
