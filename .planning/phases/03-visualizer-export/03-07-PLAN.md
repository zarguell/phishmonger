---
phase: 03-visualizer-export
plan: 07
type: execute
wave: 4
depends_on: ["03-05", "03-06"]
files_modified: [src/App.tsx, src/components/preview/SlideWrapper.tsx, src/index.css]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "App.tsx has viewMode state ('edit' | 'preview')"
    - "Preview Mode button disabled when no annotations exist"
    - "Preview mode renders SlideWrapper with EmailColumn and AnnotationColumn"
    - "ExportButton renders in preview mode header"
    - "SlideWrapper accepts forwarded ref from App.tsx"
  artifacts:
    - path: "src/App.tsx"
      provides: "App with preview mode toggle"
    - path: "src/components/preview/SlideWrapper.tsx"
      provides: "SlideWrapper with forwardRef"
    - path: "src/index.css"
      provides: "CSS for preview mode layout"
  key_links:
    - from: "App.tsx"
      to: "SlideWrapper"
      via: "import and JSX usage with ref"
      pattern: "<SlideWrapper.*ref="
    - from: "App.tsx"
      to: "ExportButton"
      via: "import and JSX usage"
      pattern: "<ExportButton"
    - from: "App.tsx"
      to: "EmailColumn"
      via: "JSX component in SlideWrapper"
      pattern: "<EmailColumn"
    - from: "App.tsx"
      to: "AnnotationColumn"
      via: "JSX component in SlideWrapper"
      pattern: "<AnnotationColumn"
---

<objective>
Integrate preview mode and export button into App.tsx.

Purpose: Enable users to toggle to preview mode showing the slide layout with annotations, arrows, and export functionality.
Output: Updated App.tsx with preview mode, SlideWrapper with forwardRef, and preview mode CSS.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-visualizer-export/03-CONTEXT.md

@src/App.tsx
@src/components/preview/SlideWrapper.tsx
@src/components/preview/EmailColumn.tsx
@src/components/preview/AnnotationColumn.tsx
@src/types/annotations.ts

# Prior Phase 1-3 plans
@.planning/phases/01-editor-foundation/01-06-SUMMARY.md
@.planning/phases/02-technique-annotations/02-02-SUMMARY.md
@.planning/phases/03-visualizer-export/03-05-SUMMARY.md
@.planning/phases/03-visualizer-export/03-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Update SlideWrapper to accept forwarded ref</name>
  <files>src/components/preview/SlideWrapper.tsx</files>
  <action>
    Update src/components/preview/SlideWrapper.tsx to accept forwarded ref:

    ```tsx
    import React, { useRef, forwardRef } from 'react'
    import { useArrowCalculations } from '../../hooks/useArrowCalculations'
    import { useDebouncedResize } from '../../hooks/useDebouncedResize'
    import { ArrowOverlay } from './ArrowOverlay'

    interface SlideWrapperProps {
      children: React.ReactNode
      annotations: Record<string, import('../../types/annotations').Annotation>
    }

    export const SlideWrapper = forwardRef<HTMLDivElement, SlideWrapperProps>(
      ({ children, annotations }, ref) => {
        const internalRef = useRef<HTMLDivElement>(null)
        const containerRef = (ref as React.RefObject<HTMLDivElement>) || internalRef

        const { arrowPaths, recalculate } = useArrowCalculations({
          containerRef,
          annotations,
        })

        // Recalculate arrows on window resize (debounced 200ms)
        useDebouncedResize(recalculate, 200)

        return (
          <div ref={containerRef} className="slide-wrapper">
            {children}
            <ArrowOverlay paths={arrowPaths} />
          </div>
        )
      }
    )

    SlideWrapper.displayName = 'SlideWrapper'
    ```

    Changes:
    - Wrap component in forwardRef
    - Accept ref as second parameter
    - Use internalRef if no ref passed
    - Add displayName for React DevTools

    Why forwardRef: App.tsx needs to pass a ref to SlideWrapper for html2canvas export. React requires forwardRef pattern for components to expose their internal DOM refs to parents.
  </action>
  <verify>grep -q "forwardRef" src/components/preview/SlideWrapper.tsx && grep -q "displayName" src/components/preview/SlideWrapper.tsx</verify>
  <done>SlideWrapper accepts forwarded ref for export</done>
</task>

<task type="auto">
  <name>Add preview mode to App.tsx</name>
  <files>src/App.tsx</files>
  <action>
    Update src/App.tsx to add preview mode and export button:

    ```tsx
    import { useState, useEffect, useRef } from 'react'
    import { HTMLInput } from './components/HTMLInput'
    import { Editor } from './components/Editor'
    import type { InputMode } from './components/ModeToggle'
    import { Preview } from './components/Preview'
    import { LureList } from './components/LureList'
    import { SlideWrapper } from './components/preview/SlideWrapper'
    import { EmailColumn } from './components/preview/EmailColumn'
    import { AnnotationColumn } from './components/preview/AnnotationColumn'
    import { ExportButton } from './components/export/ExportButton'
    import type { Annotation } from './types/annotations'
    import { loadAnnotations, saveAnnotations } from './utils/storage'
    import './index.css'

    const STORAGE_KEY = 'phishmonger-html-source'
    const MODE_KEY = 'phishmonger-input-mode'

    type ViewMode = 'edit' | 'preview'

    function App() {
      const [inputMode, setInputMode] = useState<InputMode>(() => {
        const savedMode = localStorage.getItem(MODE_KEY) as InputMode | null
        return savedMode || 'html'
      })
      const [htmlSource, setHtmlSource] = useState(() => {
        const saved = localStorage.getItem(STORAGE_KEY)
        return saved || '<p>Start typing your phishing email here...</p>'
      })
      const [annotations, setAnnotations] = useState<Record<string, Annotation>>(() => {
        return loadAnnotations()
      })
      const [viewMode, setViewMode] = useState<ViewMode>('edit')
      const slideWrapperRef = useRef<HTMLDivElement>(null)

      // Save to LocalStorage whenever htmlSource changes
      useEffect(() => {
        localStorage.setItem(STORAGE_KEY, htmlSource)
      }, [htmlSource])

      // Save input mode preference
      useEffect(() => {
        localStorage.setItem(MODE_KEY, inputMode)
      }, [inputMode])

      // Save annotations to LocalStorage
      useEffect(() => {
        saveAnnotations(annotations)
      }, [annotations])

      const updateAnnotation = (lureId: string, updates: Partial<Annotation>) => {
        setAnnotations(prev => ({
          ...prev,
          [lureId]: {
            ...prev[lureId],
            ...updates,
            lureId,
            updatedAt: new Date().toISOString()
          }
        }))
      }

      const handleMarkLure = (updatedHtml: string) => {
        setHtmlSource(updatedHtml)
      }

      const handleRemoveLure = (lureId: string) => {
        // Remove all spans with matching data-lure-id from HTML source
        const parser = new DOMParser()
        const doc = parser.parseFromString(htmlSource, 'text/html')
        const lureElements = doc.querySelectorAll(`[data-lure-id="${lureId}"]`)

        lureElements.forEach((el) => {
          const parent = el.parentNode
          if (parent) {
            while (el.firstChild) {
              parent.insertBefore(el.firstChild, el)
            }
            parent.removeChild(el)
          }
        })

        setHtmlSource(doc.body.innerHTML)

        // Remove annotation
        setAnnotations(prev => {
          const { [lureId]: removed, ...rest } = prev
          return rest
        })
      }

      if (viewMode === 'preview') {
        return (
          <div className="app app-preview-mode">
            <header className="app-header">
              <h1>Phish Monger - Preview Mode</h1>
              <div className="header-actions">
                <button
                  onClick={() => setViewMode('edit')}
                  className="back-to-edit-button"
                  type="button"
                >
                  Back to Edit
                </button>
                <ExportButton
                  slideWrapperRef={slideWrapperRef}
                  projectTitle="phish-analysis"
                />
              </div>
            </header>
            <main className="app-main app-main-preview">
              <SlideWrapper
                ref={slideWrapperRef}
                annotations={annotations}
              >
                <EmailColumn htmlSource={htmlSource} />
                <AnnotationColumn annotations={annotations} />
              </SlideWrapper>
            </main>
          </div>
        )
      }

      return (
        <div className="app">
          <header className="app-header">
            <h1>Phish Monger</h1>
            <p>Phishing Email Annotation Tool</p>
            <div className="header-actions">
              <button
                onClick={() => setViewMode('preview')}
                className="preview-mode-button"
                type="button"
                disabled={Object.keys(annotations).length === 0}
              >
                Preview Mode
              </button>
            </div>
          </header>
          <main className="app-main">
            <div className="input-column">
              <div className="mode-toggle">
                <label className="mode-toggle-label">
                  <input
                    type="radio"
                    name="inputMode"
                    value="html"
                    checked={inputMode === 'html'}
                    onChange={(e) => setInputMode(e.target.value as InputMode)}
                  />
                  <span>HTML Input</span>
                </label>
                <label className="mode-toggle-label">
                  <input
                    type="radio"
                    name="inputMode"
                    value="richtext"
                    checked={inputMode === 'richtext'}
                    onChange={(e) => setInputMode(e.target.value as InputMode)}
                  />
                  <span>Rich Text</span>
                </label>
              </div>
              {inputMode === 'html' ? (
                <HTMLInput
                  value={htmlSource}
                  onChange={setHtmlSource}
                />
              ) : (
                <Editor
                  content={htmlSource}
                  onUpdate={setHtmlSource}
                />
              )}
            </div>
            <div className="preview-column">
              <Preview
                htmlSource={htmlSource}
                onUpdate={handleMarkLure}
              />
            </div>
            <div className="lure-list-column">
              <LureList
                htmlSource={htmlSource}
                onRemoveLure={handleRemoveLure}
                annotations={annotations}
                onUpdateAnnotation={updateAnnotation}
              />
            </div>
          </main>
        </div>
      )
    }

    export default App
    ```

    Changes:
    - Add ViewMode type ('edit' | 'preview')
    - Add viewMode state and setViewMode function
    - Add slideWrapperRef for export
    - Import SlideWrapper, EmailColumn, AnnotationColumn, ExportButton
    - Add conditional rendering: if viewMode === 'preview', show slide layout
    - Add "Preview Mode" button in edit mode header
    - Add "Back to Edit" and "Export PNG" buttons in preview mode header
    - Disable Preview Mode button when no annotations exist

    Why conditional rendering: Per Phase 3 architecture, Preview Mode is a separate view showing the slide layout with annotations and arrows. Edit Mode shows the three-column editor workflow.

    Why disable preview when no annotations: Preview mode requires annotations to render cards and arrows. Empty state is handled in AnnotationColumn, but preventing accidental preview is better UX.
  </action>
  <verify>grep -q "ViewMode" src/App.tsx && grep -q "ExportButton" src/App.tsx && grep -q "SlideWrapper" src/App.tsx</verify>
  <done>App.tsx updated with preview mode toggle and export button</done>
</task>

<task type="auto">
  <name>Add CSS for preview mode and export button</name>
  <files>src/index.css</files>
  <action>
    Add CSS to src/index.css for preview mode and export button:

    ```css
    /* Preview Mode Layout */
    .app-preview-mode {
      width: 100%;
      min-height: 100vh;
      background: #f8f9fa;
    }

    .app-main-preview {
      display: flex;
      justify-content: center;
      padding: 40px;
      overflow: auto;
    }

    /* Header Actions */
    .header-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    /* Preview Mode Button */
    .preview-mode-button {
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .preview-mode-button:hover:not(:disabled) {
      background: #0056b3;
    }

    .preview-mode-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Back to Edit Button */
    .back-to-edit-button {
      padding: 8px 16px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .back-to-edit-button:hover {
      background: #545b62;
    }

    /* Export Button */
    .export-button {
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .export-button:hover:not(:disabled) {
      background: #218838;
    }

    .export-button:disabled {
      background: #6c757d;
      cursor: not-allowed;
      opacity: 0.6;
    }

    /* Export Error */
    .export-error {
      margin-top: 8px;
      padding: 8px 12px;
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      border-radius: 4px;
      font-size: 12px;
    }

    .export-button-container {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    ```

    Why button colors: Green (#28a745) for export (success action), Blue (#007bff) for preview mode (primary action), Gray (#6c757d) for back button (secondary action).

    Why overflow: auto on .app-main-preview: The slide wrapper is 1600px wide, which may exceed viewport width on smaller screens. overflow: auto enables horizontal scrolling to view the full slide.

    Note: box-shadow and filter properties are NOT used in export-related CSS since html2canvas has limited support (per Phase 3 Research Pitfall 3).
  </action>
  <verify>grep -q "\.export-button" src/index.css && grep -q "\.preview-mode-button" src/index.css</verify>
  <done>CSS for preview mode and export button added</done>
</task>

</tasks>

<verification>
- App.tsx has ViewMode type and viewMode state
- Preview Mode button renders in edit mode header
- Preview Mode button is disabled when no annotations exist
- Clicking Preview Mode switches to preview view
- Preview view renders SlideWrapper with EmailColumn and AnnotationColumn
- Back to Edit button returns to editor view
- ExportButton renders in preview mode header
- SlideWrapper accepts forwarded ref from App.tsx
- Export button is clickable and shows "Exporting..." state
- CSS provides proper styling for all buttons and layout
</verification>

<success_criteria>
- User can toggle to Preview Mode showing slide with annotations and arrows
- Export button downloads high-resolution PNG (2x scale)
- Exported filename format: phish-analysis-{title}-{timestamp}.png
- Exported PNG includes all visual elements burned in
- All 6 VIS requirements satisfied (VIS-01 through VIS-06)
- Phase 3 complete and ready for Phase 4 (NIST Phish Scale Scoring)
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualizer-export/03-07-SUMMARY.md`
</output>
