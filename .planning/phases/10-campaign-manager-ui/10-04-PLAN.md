---
phase: 10-campaign-manager-ui
plan: 04
type: execute
wave: 3
depends_on: ["10-02", "10-03"]
files_modified:
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can open CampaignManager via 'Campaigns' button in header"
    - "User can create new campaign from CampaignManager"
    - "User can edit campaign by clicking Edit button on card"
    - "User can delete campaign via confirm dialog"
    - "User can export campaign to JSON file"
    - "User can import campaign from JSON file"
    - "User can add current project to campaign via editor"
    - "Campaign data persists across page refreshes"
  artifacts:
    - path: "src/App.tsx"
      provides: "App integration with campaign modals"
      contains: "CampaignManager, CampaignEditor imports and state"
  key_links:
    - from: "App.tsx"
      to: "src/components/campaign/CampaignManager.tsx"
      via: "import CampaignManager"
      pattern: "import.*CampaignManager.*from"
    - from: "App.tsx"
      to: "src/components/campaign/CampaignEditor.tsx"
      via: "import CampaignEditor"
      pattern: "import.*CampaignEditor.*from"
    - from: "App.tsx"
      to: "src/hooks/useCampaigns.ts"
      via: "useCampaigns for accessing campaigns"
      pattern: "useCampaigns"
    - from: "App.tsx"
      to: "src/types/campaign.ts"
      via: "Campaign type for currentCampaign state"
      pattern: "import.*Campaign.*from.*campaign"
---

<objective>
Integrate CampaignManager and CampaignEditor components into App.tsx, adding the "Campaigns" button to the header and wiring up all campaign CRUD operations with proper state management.

Purpose: This is the final integration step that makes the campaign management UI accessible to users. It connects all the components built in previous plans and ensures the full campaign workflow works end-to-end.

Output: Updated App.tsx with campaign management fully integrated - Campaigns button in header, both modals wired with state, and all CRUD operations working correctly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-campaign-manager-ui/10-RESEARCH.md
@.planning/phases/10-campaign-manager-ui/10-CONTEXT.md
@.planning/phases/10-campaign-manager-ui/10-02-SUMMARY.md
@.planning/phases/10-campaign-manager-ui/10-03-SUMMARY.md

@src/App.tsx
@src/hooks/useCampaigns.ts
@src/types/campaign.ts
@src/types/phish.ts
@src/components/campaign/CampaignManager.tsx
@src/components/campaign/CampaignEditor.tsx
</context>

<tasks>

<task type="auto">
  <name>Add campaign state and imports to App.tsx</name>
  <files>src/App.tsx</files>
  <action>
    Add campaign management state and imports to App.tsx:

    Imports (add with other imports at top):
    - import { useCampaigns } from './hooks/useCampaigns'
    - import type { Campaign } from './types/campaign'
    - import type { Phish } from './types/phish'
    - import { CampaignManager } from './components/campaign/CampaignManager'
    - import { CampaignEditor } from './components/campaign/CampaignEditor'

    State (add with other useState declarations):
    - const [showCampaignManager, setShowCampaignManager] = useState(false)
    - const [editingCampaign, setEditingCampaign] = useState<Campaign | undefined>(undefined)

    Hook call (add with other hooks like useCustomTechniques):
    - const { campaigns, addCampaign, updateCampaign, deleteCampaign, addPhishToCampaign, removePhishFromCampaign, updatePhishInCampaign } = useCampaigns()

    Build currentProject Phish object (for passing to CampaignEditor):
    - Create object from existing App state (htmlSource, annotations, scoring, metadata, inputMode)
    - Needs an id: generate with crypto.randomUUID() or reuse existing from localStorage
    - Add to useEffect or compute on-demand when opening editor

    Note: App currently stores project data separately (htmlSource, annotations, etc.)
    - We need to construct a Phish object for copyPhishForCampaign
    - Do this in a useMemo or handler function
  </action>
  <verify>
    App.tsx has:
    - Campaign and Phish type imports
    - CampaignManager and CampaignEditor component imports
    - useCampaigns hook called
    - showCampaignManager state
    - editingCampaign state
    - campaigns available from hook
  </verify>
  <done>
    Campaign state and hooks added to App.tsx. Campaign data loads from LocalStorage via useCampaigns.
  </done>
</task>

<task type="auto">
  <name>Add "Campaigns" button to header and wire CampaignManager modal</name>
  <files>src/App.tsx</files>
  <action>
    Add "Campaigns" button to App header and wire CampaignManager:

    Button placement:
    - Add in header-actions div (with Undo Annotation, Preview Mode, ? buttons)
    - Position: after "Manage Techniques" button, before Preview Mode
    - Text: "Campaigns"
    - Styling: same as other header buttons

    Button onClick:
    - setShowCampaignManager(true)

    CampaignManager modal (add at end of App return, before other modals):
    - Condition: {showCampaignManager && (
    - Props:
      * isOpen: showCampaignManager (or just check existence for modal pattern)
      * onClose: () => setShowCampaignManager(false)
      * onEditCampaign: handleEditCampaign (see below)
      * currentProject: constructed Phish from current App state

    Handle functions:
    - handleEditCampaign(campaign: Campaign):
      * setEditingCampaign(campaign)
      * setShowCampaignManager(false) // Close list, open editor

    - handleCreateCampaign: (data: CampaignInput):
      * Call addCampaign(data)
      * No need to open editor - user can edit via card

    Place CampaignManager JSX in modal section (after KeyboardShortcutHelp, before or after TechniqueLibrary)

    Follow existing modal pattern (TechniqueLibrary) for consistent UX.
  </action>
  <verify>
    App.tsx has:
    - "Campaigns" button in header-actions
    - CampaignManager modal conditionally rendered
    - onEditCampaign callback sets editingCampaign
    - onClose callback closes modal
  </verify>
  <done>
    "Campaigns" button opens CampaignManager modal. User can view all campaigns and click Edit to open editor.
  </done>
</task>

<task type="auto">
  <name>Wire CampaignEditor modal with save handlers</name>
  <files>src/App.tsx</files>
  <action>
    Add CampaignEditor modal and wire save operations:

    CampaignEditor modal (add after CampaignManager):
    - Condition: {editingCampaign && (
    - Props:
      * campaign: editingCampaign
      * onClose: handleCloseEditor
      * onSave: handleSaveCampaign
      * currentProject: constructed Phish from current App state

    Handle functions:
    - handleCloseEditor:
      * setEditingCampaign(undefined)
      * Optionally return to campaign list: setShowCampaignManager(true)

    - handleSaveCampaign: (campaignId: string, updates: Partial<Campaign>):
      * Call updateCampaign(campaignId, updates)
      * setEditingCampaign(undefined)
      * Optionally: show success feedback

    Current Phish construction:
    - Create helper function or useMemo to build Phish from App state:
      * id: Use a consistent ID (could be stored in localStorage as 'phishmonger-project-id')
      * metadata: { title, author, createdAt, updatedAt } from existing metadata state
      * htmlSource: from htmlSource state
      * annotations: from annotations state
      * scoring: from scoring state
      * inputMode: from inputMode state
    - On first render, check if project ID exists in localStorage
    - If not, generate with crypto.randomUUID() and store

    Modal placement:
    - After CampaignManager in JSX
    - Both modals use same z-index pattern (z-50)
    - Only one visible at a time (mutually exclusive state)

    Close button X in CampaignEditor header should call handleCloseEditor.
  </action>
  <verify>
    App.tsx has:
    - CampaignEditor modal conditionally rendered
    - handleSaveCampaign calls updateCampaign
    - handleCloseEditor clears editingCampaign state
    - currentProject Phish constructed from App state
    - Editor closes and returns to campaign list after save
  </verify>
  <done>
    CampaignEditor modal opens when editing campaign. Save updates campaign in LocalStorage. Close returns to campaign list.
  </done>
</task>

</tasks>

<verification>
1. "Campaigns" button visible in header
2. Clicking button opens CampaignManager modal
3. CampaignManager shows all campaigns from LocalStorage
4. Create new campaign works (creates empty campaign)
5. Edit button on card opens CampaignEditor
6. CampaignEditor shows campaign details and phishes
7. "Add Current Project" copies current App state into campaign
8. Save in editor updates campaign
9. Delete in list removes campaign
10. Export downloads campaign JSON
11. Import reads and creates campaign
12. All changes persist after page refresh
13. Modals close on backdrop click
14. Only one modal visible at a time
</verification>

<success_criteria>
1. Campaign management fully integrated into App.tsx
2. User can access campaigns via "Campaigns" button
3. All CRUD operations work end-to-end
4. Campaign data persists across sessions
5. UI follows existing patterns (consistent with TechniqueLibrary)
6. No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/10-campaign-manager-ui/10-04-SUMMARY.md`
</output>
