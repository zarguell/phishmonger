---
phase: 03-visualizer-export
plan: 04
type: execute
wave: 2
depends_on: ["03-02", "03-03"]
files_modified: [src/components/preview/ArrowOverlay.tsx, src/components/preview/SlideWrapper.tsx, src/hooks/useArrowCalculations.ts, src/hooks/useDebouncedResize.ts, src/index.css]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SVG overlay renders on top of slide with elbow-connector arrows"
    - "Arrows connect from lure right edge → bus line (x=1000) → card left edge"
    - "Arrows recalculate on window resize (debounced 200ms)"
    - "SVG has pointer-events: none to allow text selection underneath"
  artifacts:
    - path: "src/components/preview/ArrowOverlay.tsx"
      provides: "SVG overlay with elbow-connector arrows"
    - path: "src/hooks/useArrowCalculations.ts"
      provides: "DOM coordinate calculations for arrow paths"
      exports: ["useArrowCalculations"]
    - path: "src/hooks/useDebouncedResize.ts"
      provides: "Debounced resize handler"
      exports: ["useDebouncedResize"]
  key_links:
    - from: "ArrowOverlay.tsx"
      to: "useArrowCalculations"
      via: "import and hook usage"
      pattern: "useArrowCalculations\\(.*\\)"
    - from: "useArrowCalculations.ts"
      to: "document.querySelector"
      via: "DOM queries for lure elements"
      pattern: "querySelector.*data-lure-id"
    - from: "SlideWrapper.tsx"
      to: "ArrowOverlay"
      via: "JSX component rendered after children"
      pattern: "<ArrowOverlay"
---

<objective>
Create SVG overlay system with elbow-connector arrows linking lures to annotation cards.

Purpose: Visualize connections between highlighted lures and their explanation cards through a shared vertical bus line (x=1000px).
Output: ArrowOverlay component and useArrowCalculations hook for dynamic coordinate tracking.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-visualizer-export/03-CONTEXT.md
@.planning/phases/03-visualizer-export/03-RESEARCH.md

@src/components/preview/SlideWrapper.tsx
@src/components/preview/EmailColumn.tsx
@src/components/preview/AnnotationColumn.tsx
@src/components/annotation/AnnotationCard.tsx
@src/types/annotations.ts

# Prior Phase 1-2 plans
@.planning/phases/01-editor-foundation/01-06-SUMMARY.md
@.planning/phases/02-technique-annotations/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create useDebouncedResize hook for performance</name>
  <files>src/hooks/useDebouncedResize.ts</files>
  <action>
    Create src/hooks/useDebouncedResize.ts:

    ```tsx
    import { useEffect } from 'react'

    /**
     * Debounces window resize events to prevent excessive layout recalculations.
     * Per Phase 3 Research: debounce with 100-200ms delay prevents layout thrashing.
     */
    export function useDebouncedResize(callback: () => void, delay: number = 200) {
      useEffect(() => {
        let timeoutId: NodeJS.Timeout

        const handler = () => {
          clearTimeout(timeoutId)
          timeoutId = setTimeout(() => {
            callback()
          }, delay)
        }

        window.addEventListener('resize', handler)

        return () => {
          clearTimeout(timeoutId)
          window.removeEventListener('resize', handler)
        }
      }, [callback, delay])
    }
    ```

    Why debounced resize: Per Phase 3 Research, recalculating layout on every resize event fires rapidly and causes performance issues. Debouncing with 200ms ensures calculations run only after resizing settles.

    Why 200ms delay: Balances responsiveness with performance. 100ms is minimum, 200ms provides smoother experience during active resizing.
  </action>
  <verify>test -f src/hooks/useDebouncedResize.ts && grep -q "useDebouncedResize" src/hooks/useDebouncedResize.ts</verify>
  <done>useDebouncedResize hook created with 200ms delay</done>
</task>

<task type="auto">
  <name>Create useArrowCalculations hook for coordinate tracking</name>
  <files>src/hooks/useArrowCalculations.ts</files>
  <action>
    Create src/hooks/useArrowCalculations.ts:

    ```tsx
    import { useLayoutEffect, useState, useRef } from 'react'
    import type { Annotation } from '../types/annotations'

    export interface ArrowPath {
      lureId: string
      start: { x: number; y: number }    // Right edge of lure span
      mid1: { x: number; y: number }     // Bus line at lure Y
      mid2: { x: number; y: number }     // Bus line at card Y
      end: { x: number; y: number }      // Left edge of annotation card
    }

    interface UseArrowCalculationsProps {
      containerRef: React.RefObject<HTMLDivElement>
      annotations: Record<string, Annotation>
    }

    /**
     * Calculates elbow-connector arrow paths from lure spans to annotation cards.
     * Uses container-relative coordinates (getBoundingClientRect) for tracking.
     * Per Phase 3 Research: useLayoutEffect prevents visual flicker on initial render.
     */
    export function useArrowCalculations({ containerRef, annotations }: UseArrowCalculationsProps) {
      const [arrowPaths, setArrowPaths] = useState<ArrowPath[]>([])
      const calculationInProgress = useRef(false)

      const calculatePaths = () => {
        if (!containerRef.current || calculationInProgress.current) return

        calculationInProgress.current = true

        const containerRect = containerRef.current.getBoundingClientRect()
        const paths: ArrowPath[] = []
        const busX = 1000 // Per Phase 3 Context: center of gutter at x=1000px

        Object.values(annotations).forEach((annotation) => {
          // Find lure span element
          const lureElement = containerRef.current?.querySelector(
            `[data-lure-id="${annotation.lureId}"]`
          ) as HTMLElement

          // Find annotation card element
          const cardElement = containerRef.current?.querySelector(
            `[data-card-id="${annotation.lureId}"]`
          ) as HTMLElement

          if (!lureElement || !cardElement) return

          // Get viewport-relative coordinates
          const lureRect = lureElement.getBoundingClientRect()
          const cardRect = cardElement.getBoundingClientRect()

          // Convert to container-relative coordinates
          const start = {
            x: lureRect.right - containerRect.left,
            y: lureRect.top + lureRect.height / 2 - containerRect.top,
          }

          const end = {
            x: cardRect.left - containerRect.left,
            y: cardRect.top + cardRect.height / 2 - containerRect.top,
          }

          paths.push({
            lureId: annotation.lureId,
            start,
            mid1: { x: busX, y: start.y },
            mid2: { x: busX, y: end.y },
            end,
          })
        })

        setArrowPaths(paths)
        calculationInProgress.current = false
      }

      // Synchronous measurement before paint (prevents flicker)
      useLayoutEffect(() => {
        calculatePaths()
      }, [annotations])

      return { arrowPaths, recalculate: calculatePaths }
    }
    ```

    Why container-relative coordinates: Per Phase 3 Research Pitfall 1, getBoundingClientRect() returns viewport-relative coordinates. Subtracting containerRect.left/top converts to container-relative, ensuring arrows track correctly on scroll/resize.

    Why useLayoutEffect: Per Phase 3 Research Pitfall 2, using useEffect causes visual flicker as arrows jump on first paint. useLayoutEffect runs synchronously after DOM updates but before paint.

    Why busX = 1000: Per Phase 3 Context, the bus line is at the center of the gutter: 960px (email width) + 40px (half of 80px gutter) = 1000px.
  </action>
  <verify>test -f src/hooks/useArrowCalculations.ts && grep -q "useArrowCalculations" src/hooks/useArrowCalculations.ts</verify>
  <done>useArrowCalculations hook created with container-relative coordinates</done>
</task>

<task type="auto">
  <name>Create ArrowOverlay SVG component</name>
  <files>src/components/preview/ArrowOverlay.tsx</files>
  <action>
    Create src/components/preview/ArrowOverlay.tsx:

    ```tsx
    import React from 'react'
    type { ArrowPath } from '../../hooks/useArrowCalculations'

    interface ArrowOverlayProps {
      paths: ArrowPath[]
    }

    export function ArrowOverlay({ paths }: ArrowOverlayProps) {
      return (
        <svg
          className="arrow-overlay"
          width="1600"
          height="100%"
          xmlns="http://www.w3.org/2000/svg"
        >
          <defs>
            <marker
              id="arrowhead"
              markerWidth="10"
              markerHeight="7"
              refX="10"
              refY="3.5"
              orient="auto"
            >
              <polygon points="0 0, 10 3.5, 0 7" fill="#FF4500" />
            </marker>
          </defs>
          {paths.map((path) => (
            <path
              key={path.lureId}
              d={`M ${path.start.x} ${path.start.y} L ${path.mid1.x} ${path.mid1.y} L ${path.mid2.x} ${path.mid2.y} L ${path.end.x} ${path.end.y}`}
              stroke="#FF4500"
              strokeWidth="2"
              fill="none"
              markerEnd="url(#arrowhead)"
            />
          ))}
        </svg>
      )
    }
    ```

    Why SVG overlay: Per Phase 3 Research, SVG is preferred over Canvas for overlays because it's DOM-like, easier to style with CSS, and handles dynamic path rendering efficiently.

    Why pointer-events: none: Per Phase 3 Research Pitfall 5, the overlay must not block text selection or clicks. CSS will set pointer-events: none on the arrow-overlay class.

    Why OrangeRed (#FF4500): Per Phase 3 Context, unified color creates clear visual hierarchy. Audience knows exactly where to look.

    Elbow connector path: M start L mid1 (horizontal to bus) L mid2 (vertical through bus) L end (horizontal to card).
  </action>
  <verify>test -f src/components/preview/ArrowOverlay.tsx && grep -q "arrow-overlay" src/components/preview/ArrowOverlay.tsx</verify>
  <done>ArrowOverlay component created with elbow-connector paths</done>
</task>

<task type="auto">
  <name>Update SlideWrapper to integrate arrow overlay</name>
  <files>src/components/preview/SlideWrapper.tsx</files>
  <action>
    Update src/components/preview/SlideWrapper.tsx to include arrow overlay:

    ```tsx
    import React, { useRef } from 'react'
    import { useArrowCalculations } from '../../hooks/useArrowCalculations'
    import { useDebouncedResize } from '../../hooks/useDebouncedResize'
    import { ArrowOverlay } from './ArrowOverlay'

    interface SlideWrapperProps {
      children: React.ReactNode
      annotations: Record<string, import('../../types/annotations').Annotation>
    }

    export function SlideWrapper({ children, annotations }: SlideWrapperProps) {
      const containerRef = useRef<HTMLDivElement>(null)
      const { arrowPaths, recalculate } = useArrowCalculations({
        containerRef,
        annotations,
      })

      // Recalculate arrows on window resize (debounced 200ms)
      useDebouncedResize(recalculate, 200)

      return (
        <div ref={containerRef} className="slide-wrapper">
          {children}
          <ArrowOverlay paths={arrowPaths} />
        </div>
      )
    }
    ```

    Changes:
    - Add useRef for container measurement
    - Import and use useArrowCalculations hook
    - Import and use useDebouncedResize hook
    - Render ArrowOverlay after children (z-index natural stacking)
    - Pass annotations to hook for path calculations

    Why ref on container: Per Phase 3 Research Pattern 1, all calculations must be relative to a stable container. The ref provides the DOM element for getBoundingClientRect() measurements.

    Why debounced resize: Window resize changes element positions, requiring arrow recalculation. Debouncing prevents excessive recalculations during active resizing.
  </action>
  <verify>grep -q "useArrowCalculations" src/components/preview/SlideWrapper.tsx && grep -q "ArrowOverlay" src/components/preview/SlideWrapper.tsx</verify>
  <done>SlideWrapper integrates arrow overlay with resize handling</done>
</task>

<task type="auto">
  <name>Add CSS for arrow overlay with pointer-events: none</name>
  <files>src/index.css</files>
<action>
    Add CSS to src/index.css for arrow overlay:

    ```css
    /* Arrow Overlay */
    .arrow-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* Allow text selection underneath */
      z-index: 10; /* Above content but below modals */
    }
    ```

    Why pointer-events: none: Per Phase 3 Research Pitfall 5, without this the SVG overlay blocks all interactions with underlying content (text selection, clicks, etc.). Setting none allows clicks to pass through to the email and cards.

    Why z-index: 10: Ensures arrows appear above the email and cards, but below any modal overlays that might appear later.
  </action>
  <verify>grep -q "\.arrow-overlay" src/index.css && grep -q "pointer-events: none" src/index.css</verify>
  <done>CSS for arrow overlay added with pointer-events: none</done>
</task>

<task type="auto">
  <name>Add data-card-id attribute to AnnotationCard for measurement</name>
  <files>src/components/annotation/AnnotationCard.tsx</files>
  <action>
    Update src/components/annotation/AnnotationCard.tsx to add data-card-id:

    ```tsx
    import React from 'react'
    import type { Annotation } from '../types/annotations'

    interface AnnotationCardProps {
      annotation: Annotation
      style?: React.CSSProperties
    }

    export function AnnotationCard({ annotation, style }: AnnotationCardProps) {
      return (
        <div
          className="annotation-card"
          style={style}
          data-card-id={annotation.lureId} // For arrow calculations
        >
          <h3 className="annotation-card-title">
            {annotation.techniqueId}
          </h3>
          <span className="annotation-card-badge">
            {annotation.techniqueId}
          </span>
          <p className="annotation-card-explanation">
            {annotation.explanation}
          </p>
        </div>
      )
    }
    ```

    Changes: Add data-card-id attribute to the div.

    Why data-card-id: Per useArrowCalculations hook, the card element is queried using querySelector(`[data-card-id="${annotation.lureId}"]`). This attribute enables DOM measurement for arrow endpoint calculations.
  </action>
  <verify>grep -q "data-card-id" src/components/annotation/AnnotationCard.tsx</verify>
  <done>AnnotationCard has data-card-id for DOM measurements</done>
</task>

</tasks>

<verification>
- ArrowOverlay renders SVG with pointer-events: none
- Arrows follow elbow path: lure right → bus (x=1000) → card left
- Arrowhead marker points at annotation cards
- Arrows recalculate on window resize (debounced 200ms)
- AnnotationCard has data-card-id for DOM queries
- SlideWrapper passes annotations to useArrowCalculations
- SVG has width 1600px matching slide wrapper
</verification>

<success_criteria>
- SVG overlay renders on top of slide without blocking interactions
- Elbow-connector arrows visually connect lures to their cards
- Arrows route through shared bus line at x=1000px
- Arrows track correctly on window resize
- Visual system ready for export (Plan 05)
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualizer-export/03-04-SUMMARY.md`
</output>
