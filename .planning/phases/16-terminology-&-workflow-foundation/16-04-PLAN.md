---
phase: 16-terminology-workflow-foundation
plan: 04
type: execute
wave: 3
depends_on: [16-03]
files_modified:
  - src/App.tsx
  - src/utils/storage.ts
autonomous: false
user_setup: []

must_haves:
  truths:
    - User sees campaigns list as the first screen when launching the application (new users)
    - Existing users with data see the editor view (backward compatibility)
    - "Campaigns" button in header still opens campaign manager
    - User can close campaign manager to access the editor
    - Application workflow is centered around campaigns-first UX
  artifacts:
    - path: "src/App.tsx"
      provides: "App component with campaigns-first default view"
      contains: "showCampaignManager = true"
    - path: "src/utils/storage.ts"
      provides: "Utilities for checking existing user data"
      exports: ["hasExistingPhishData"]
  key_links:
    - from: "src/App.tsx"
      to: "localStorage"
      via: "loadPhishMetadata check on mount"
      pattern: "hasExistingData|loadPhishMetadata"
    - from: "src/App.tsx"
      to: "src/components/campaign/CampaignManager"
      via: "showCampaignManager state initialization"
      pattern: "useState.*showCampaignManager"
---

<objective>
Change default landing view from standalone editor to campaigns list

Purpose: Implement campaigns-first workflow by making the campaigns list the default landing view for new users. Existing users with data maintain backward compatibility by defaulting to the editor. This reorients the application around the campaigns workflow while preserving existing user experience.

Output: Updated App.tsx with smart default view based on existing user data
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-terminology-&-workflow-foundation/16-RESEARCH.md

@src/App.tsx
@src/utils/storage.ts
@src/components/campaign/CampaignManager.tsx
@.planning/phases/16-terminology-&-workflow-foundation/16-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add utility function to check for existing user data</name>
  <files>src/utils/storage.ts</files>
  <action>
    Add a helper function to detect if user has existing phish data:

    Add this function after the savePhishMetadata function (around line 105):

    ```typescript
    /**
     * Check if user has existing phish data (for backward compatibility)
     *
     * Returns true if the user has customized their phish metadata,
     * indicating they are an existing user who should see the editor view.
     *
     * @returns true if user has existing data, false for new users
     */
    export function hasExistingPhishData(): boolean {
      try {
        const metadataStr = localStorage.getItem(METADATA_KEY);
        if (!metadataStr) {
          return false; // No data at all - new user
        }

        const metadata = JSON.parse(metadataStr);
        // Check if user has customized the title from default
        // "Untitled Phish" (post-migration) or "Untitled Project" (pre-migration)
        const hasCustomTitle = metadata.title &&
          metadata.title !== 'Untitled Phish' &&
          metadata.title !== 'Untitled Project';

        return hasCustomTitle;
      } catch (error) {
        console.error('Failed to check for existing data:', error);
        return false;
      }
    }
    ```

    This function will be used to determine the default landing view.
  </action>
  <verify>grep -n "function hasExistingPhishData" src/utils/storage.ts returns a match</verify>
  <done>hasExistingPhishData utility function exists in storage.ts</done>
</task>

<task type="auto">
  <name>Task 2: Import hasExistingPhishData and add default view logic to App.tsx</name>
  <files>src/App.tsx</files>
  <action>
    1. Add hasExistingPhishData to the import statement from storage.ts:
       Update line 30 to include hasExistingPhishData:

       FROM:
       import { loadAnnotations, saveAnnotations, loadScoring, saveScoring, loadPhishMetadata, savePhishMetadata, exportProjectJSON, downloadProjectJSON, importProjectJSON }

       TO:
       import { loadAnnotations, saveAnnotations, loadScoring, saveScoring, loadPhishMetadata, savePhishMetadata, exportProjectJSON, downloadProjectJSON, importProjectJSON, hasExistingPhishData }

    2. Add the import for hasExistingPhishData to types/index.ts if it's not already exported:

       Add to src/types/index.ts (or add re-export in storage.ts if needed):

       ```typescript
       export { hasExistingPhishData } from '../utils/storage';
       ```
  </action>
  <verify>grep -n "hasExistingPhishData" src/App.tsx | head -5 returns matches in import statement</verify>
  <done>hasExistingPhishData is imported in App.tsx</done>
</task>

<task type="auto">
  <name>Task 3: Update showCampaignManager state to use smart default</name>
  <files>src/App.tsx</files>
  <action>
    Modify the showCampaignManager state initialization to use a smart default:

    Change FROM (line 133):
    ```typescript
    const [showCampaignManager, setShowCampaignManager] = useState(false)
    ```

    Change TO:
    ```typescript
    const [showCampaignManager, setShowCampaignManager] = useState(() => {
      // Campaigns-first workflow: new users see campaigns list
      // Existing users with data stay in editor for backward compatibility
      const hasData = hasExistingPhishData();
      return !hasData; // Show campaigns for new users, editor for existing users
    })
    ```

    This logic:
    - New users (no data): showCampaignManager = true → see campaigns list
    - Existing users (customized title): showCampaignManager = false → see editor

    Add a comment explaining the workflow change for future maintainers.
  </action>
  <verify>grep -A5 "showCampaignManager.*useState" src/App.tsx | grep "hasExistingPhishData" returns a match</verify>
  <done>showCampaignManager uses smart default based on existing data</done>
</task>

<task type="auto">
  <name>Task 4: Add "New Phish" button to CampaignManager for easy editor access</name>
  <files>src/components/campaign/CampaignManager.tsx</files>
  <action>
    Add a button to close the campaign manager and access the standalone editor:

    Find the button section in the header area (around line 267-311) and add a new button after "Load Sample Campaign":

    ```typescript
    <button
      onClick={() => {
        onClose();
        // Note: User can now create a new phish in the editor
      }}
      style={{
        padding: '8px 16px',
        backgroundColor: '#28a745',
        color: 'white',
        border: 'none',
        borderRadius: '6px',
        fontSize: '14px',
        fontWeight: '500',
        cursor: 'pointer',
      }}
    >
      New Phish
    </button>
    ```

    This button provides a clear path for users who want to work on a standalone phish outside of campaigns.

    NOTE: The CampaignManager component needs an onClose prop that already exists, so no prop changes needed.
  </action>
  <verify>grep -n "New Phish" src/components/campaign/CampaignManager.tsx returns a match</verify>
  <done>"New Phish" button added to CampaignManager header</done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Campaigns-first workflow with smart default view</what-built>
  <how-to-verify>
    1. Clear all localStorage data (DevTools → Application → Local Storage → Clear All)
    2. Refresh the page
    3. Verify: Campaigns modal opens automatically on first load
    4. Close the campaigns modal
    5. Create a new phish (enter a custom title)
    6. Refresh the page
    7. Verify: Editor view is shown (not campaigns modal) - backward compatibility working
    8. Click "Campaigns" button
    9. Verify: Campaigns modal opens and "New Phish" button is visible
    10. Click "New Phish"
    11. Verify: Campaigns modal closes and editor is accessible
  </how-to-verify>
  <resume-signal>Type "approved" if campaigns-first workflow works correctly for both new and existing users</resume-signal>
</task>

</tasks>

<verification>
After completing all automated tasks and before the checkpoint:
1. Run TypeScript compilation: npm run build
2. Verify no type errors
3. Run npm run dev
4. Clear localStorage to simulate new user
5. Verify campaigns list opens on first load
</verification>

<success_criteria>
1. New users see campaigns list as default landing view
2. Existing users with customized data see editor view (backward compatibility)
3. "New Phish" button in CampaignManager provides path to standalone editor
4. "Campaigns" button still opens campaign manager from editor
5. TypeScript compilation passes with no errors
6. User can navigate between campaigns list and editor seamlessly
</success_criteria>

<output>
After completion, create `.planning/phases/16-terminology-&-workflow-foundation/16-04-SUMMARY.md`
</output>
