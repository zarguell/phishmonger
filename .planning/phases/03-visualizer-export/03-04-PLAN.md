---
phase: 03-visualizer-export
plan: 04
type: execute
wave: 2
depends_on: ["03-03"]
files_modified: [src/hooks/useArrowCalculations.ts, src/hooks/useDebouncedResize.ts, src/components/annotation/AnnotationCard.tsx]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "useArrowCalculations calculates container-relative coordinates for arrow paths"
    - "useDebouncedResize debounces window resize events by 200ms"
    - "AnnotationCard has data-card-id attribute for DOM measurements"
    - "Hook queries elements by data-lure-id and data-card-id"
  artifacts:
    - path: "src/hooks/useArrowCalculations.ts"
      provides: "DOM coordinate calculations for arrow paths"
      exports: ["useArrowCalculations"]
    - path: "src/hooks/useDebouncedResize.ts"
      provides: "Debounced resize handler"
      exports: ["useDebouncedResize"]
    - path: "src/components/annotation/AnnotationCard.tsx"
      provides: "Annotation card with data-card-id attribute"
  key_links:
    - from: "useArrowCalculations.ts"
      to: "document.querySelector"
      via: "DOM queries for lure and card elements"
      pattern: "querySelector.*data-(lure|card)-id"
---

<objective>
Create custom hooks for arrow calculations and resize handling.

Purpose: Build the foundation for SVG arrow overlay with container-relative coordinate tracking and debounced resize handling.
Output: useArrowCalculations and useDebouncedResize hooks with data-card-id attribute on AnnotationCard.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-visualizer-export/03-CONTEXT.md
@.planning/phases/03-visualizer-export/03-RESEARCH.md

@src/types/annotations.ts

# Prior Phase 2-3 plans
@.planning/phases/02-technique-annotations/02-02-SUMMARY.md
@.planning/phases/03-visualizer-export/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create useDebouncedResize hook for performance</name>
  <files>src/hooks/useDebouncedResize.ts</files>
  <action>
    Create src/hooks/useDebouncedResize.ts:

    ```tsx
    import { useEffect } from 'react'

    /**
     * Debounces window resize events to prevent excessive layout recalculations.
     * Per Phase 3 Research: debounce with 100-200ms delay prevents layout thrashing.
     */
    export function useDebouncedResize(callback: () => void, delay: number = 200) {
      useEffect(() => {
        let timeoutId: NodeJS.Timeout

        const handler = () => {
          clearTimeout(timeoutId)
          timeoutId = setTimeout(() => {
            callback()
          }, delay)
        }

        window.addEventListener('resize', handler)

        return () => {
          clearTimeout(timeoutId)
          window.removeEventListener('resize', handler)
        }
      }, [callback, delay])
    }
    ```

    Why debounced resize: Per Phase 3 Research, recalculating layout on every resize event fires rapidly and causes performance issues. Debouncing with 200ms ensures calculations run only after resizing settles.

    Why 200ms delay: Balances responsiveness with performance. 100ms is minimum, 200ms provides smoother experience during active resizing.
  </action>
  <verify>test -f src/hooks/useDebouncedResize.ts && grep -q "useDebouncedResize" src/hooks/useDebouncedResize.ts</verify>
  <done>useDebouncedResize hook created with 200ms delay</done>
</task>

<task type="auto">
  <name>Create useArrowCalculations hook for coordinate tracking</name>
  <files>src/hooks/useArrowCalculations.ts</files>
  <action>
    Create src/hooks/useArrowCalculations.ts:

    ```tsx
    import { useLayoutEffect, useState, useRef } from 'react'
    import type { Annotation } from '../types/annotations'

    export interface ArrowPath {
      lureId: string
      start: { x: number; y: number }    // Right edge of lure span
      mid1: { x: number; y: number }     // Bus line at lure Y
      mid2: { x: number; y: number }     // Bus line at card Y
      end: { x: number; y: number }      // Left edge of annotation card
    }

    interface UseArrowCalculationsProps {
      containerRef: React.RefObject<HTMLDivElement>
      annotations: Record<string, Annotation>
    }

    /**
     * Calculates elbow-connector arrow paths from lure spans to annotation cards.
     * Uses container-relative coordinates (getBoundingClientRect) for tracking.
     * Per Phase 3 Research: useLayoutEffect prevents visual flicker on initial render.
     */
    export function useArrowCalculations({ containerRef, annotations }: UseArrowCalculationsProps) {
      const [arrowPaths, setArrowPaths] = useState<ArrowPath[]>([])
      const calculationInProgress = useRef(false)

      const calculatePaths = () => {
        if (!containerRef.current || calculationInProgress.current) return

        calculationInProgress.current = true

        const containerRect = containerRef.current.getBoundingClientRect()
        const paths: ArrowPath[] = []
        const busX = 1000 // Per Phase 3 Context: center of gutter at x=1000px

        Object.values(annotations).forEach((annotation) => {
          // Find lure span element
          const lureElement = containerRef.current?.querySelector(
            `[data-lure-id="${annotation.lureId}"]`
          ) as HTMLElement

          // Find annotation card element
          const cardElement = containerRef.current?.querySelector(
            `[data-card-id="${annotation.lureId}"]`
          ) as HTMLElement

          if (!lureElement || !cardElement) return

          // Get viewport-relative coordinates
          const lureRect = lureElement.getBoundingClientRect()
          const cardRect = cardElement.getBoundingClientRect()

          // Convert to container-relative coordinates
          const start = {
            x: lureRect.right - containerRect.left,
            y: lureRect.top + lureRect.height / 2 - containerRect.top,
          }

          const end = {
            x: cardRect.left - containerRect.left,
            y: cardRect.top + cardRect.height / 2 - containerRect.top,
          }

          paths.push({
            lureId: annotation.lureId,
            start,
            mid1: { x: busX, y: start.y },
            mid2: { x: busX, y: end.y },
            end,
          })
        })

        setArrowPaths(paths)
        calculationInProgress.current = false
      }

      // Synchronous measurement before paint (prevents flicker)
      useLayoutEffect(() => {
        calculatePaths()
      }, [annotations])

      return { arrowPaths, recalculate: calculatePaths }
    }
    ```

    Why container-relative coordinates: Per Phase 3 Research Pitfall 1, getBoundingClientRect() returns viewport-relative coordinates. Subtracting containerRect.left/top converts to container-relative, ensuring arrows track correctly on scroll/resize.

    Why useLayoutEffect: Per Phase 3 Research Pitfall 2, using useEffect causes visual flicker as arrows jump on first paint. useLayoutEffect runs synchronously after DOM updates but before paint.

    Why busX = 1000: Per Phase 3 Context, the bus line is at the center of the gutter: 960px (email width) + 40px (half of 80px gutter) = 1000px.
  </action>
  <verify>test -f src/hooks/useArrowCalculations.ts && grep -q "useArrowCalculations" src/hooks/useArrowCalculations.ts</verify>
  <done>useArrowCalculations hook created with container-relative coordinates</done>
</task>

<task type="auto">
  <name>Add data-card-id attribute to AnnotationCard for measurement</name>
  <files>src/components/annotation/AnnotationCard.tsx</files>
  <action>
    Update src/components/annotation/AnnotationCard.tsx to add data-card-id:

    ```tsx
    import React from 'react'
    import type { Annotation } from '../types/annotations'

    interface AnnotationCardProps {
      annotation: Annotation
      style?: React.CSSProperties
    }

    export function AnnotationCard({ annotation, style }: AnnotationCardProps) {
      return (
        <div
          className="annotation-card"
          style={style}
          data-card-id={annotation.lureId} // For arrow calculations
        >
          <h3 className="annotation-card-title">
            {annotation.techniqueId}
          </h3>
          <span className="annotation-card-badge">
            {annotation.techniqueId}
          </span>
          <p className="annotation-card-explanation">
            {annotation.explanation}
          </p>
        </div>
      )
    }
    ```

    Changes: Add data-card-id attribute to the div.

    Why data-card-id: Per useArrowCalculations hook, the card element is queried using querySelector(`[data-card-id="${annotation.lureId}"]`). This attribute enables DOM measurement for arrow endpoint calculations.
  </action>
  <verify>grep -q "data-card-id" src/components/annotation/AnnotationCard.tsx</verify>
  <done>AnnotationCard has data-card-id for DOM measurements</done>
</task>

</tasks>

<verification>
- useDebouncedResize hook created with 200ms delay
- useArrowCalculations hook calculates container-relative coordinates
- ArrowPath interface defines start, mid1, mid2, end points
- Hook queries elements by data-lure-id and data-card-id
- AnnotationCard has data-card-id attribute
- Hook uses useLayoutEffect for flicker-free rendering
</verification>

<success_criteria>
- useDebouncedResize hook ready for SlideWrapper integration
- useArrowCalculations hook ready for ArrowOverlay integration
- AnnotationCard has data-card-id for DOM queries
- Foundation ready for Plan 03-06 (ArrowOverlay component + SlideWrapper integration)
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualizer-export/03-04-SUMMARY.md`
</output>
